\documentclass[a4paper]{book}

% Using geometry.sty to have equal margins, despite twoside option. It will
% normally change the margins quite a bit; the following produces something
% close to normal LaTeX layout -- it just increases \topmargin by 2pt:
\usepackage[textwidth=345pt,textheight=598pt,centering]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancy}

\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\enskip#1}}
\fancyhf{}
\fancyhead[LE,RO]{\thepage}
\fancyhead[LO]{\nouppercase{\textit{\rightmark}}}
\fancyhead[RE]{\nouppercase{\textit{\leftmark}}}
% \def\headrulewidth{0pt}

\usepackage{abspos}
\usepackage{xcoffins}

\usepackage[inline]{enumitem}

\newlist{inl}{enumerate*}{1}
\setlist[inl]{
    label=\mbox{\rm($\roman*$)},
}

\usepackage[prefix=s]{xcolor-solarized}

\usepackage{tabularx}

\usepackage{tabto}

\usepackage{float}
\usepackage[small]{caption}

\usepackage[citestyle=numeric-comp,
    giveninits,doi=false,url=false,
    natbib,sortcites,hyperref]{biblatex}

\renewcommand{\subtitlepunct}{\addcolon\addspace}
\renewbibmacro{in:}{}
\bibliography{pseudo}

% Avoid too much space after code:
\def\paragraph#1{\noindent\textbf{#1}\enskip}

\usepackage{lmodern}

\let\origbfseries\bfseries
\def\bfseries{\fontseries{b}\selectfont}

\let\origtt\texttt
\def\texttt#1{\textnormal{\origtt{#1}}}
% Still getting warnings about OT1/cmtt/b/n ...

\usepackage{tikz}
\usetikzlibrary{matrix,calc,decorations.pathreplacing,calligraphy}
\tikzset{
    auto/.style={fill=black!12}
}

\usepackage{old-arrows}
% Keep before hyperref
\RequirePackage[hang,perpage,symbol*,bottom,stable]{footmisc}
\renewcommand{\footnotemargin}{1em}

\usepackage[pdfusetitle, hidelinks, bookmarks=false]{hyperref}
\usepackage[xparse,
    breakable,
    hooks,
    listingsutf8, documentation]{tcolorbox}

% For box/float examples
\tcbuselibrary{theorems}

\usepackage{pseudo}

% ! Duplicate of the one inside the texexp in the HOWTO section:
\pseudodefinestyle{fullwidth}{
    begin-tabular =
    \tabularx{\linewidth}[t]{@{}
        r                                      % Labels
        >{\leavevmode\pseudosetup}             % Indent, font, ...
        X                                      % Code (flexible)
        >{\leavevmode\small\color{gray}}       % Comment styling
        p{0.5\linewidth}                       % Comments (fixed)
        @{}},
    end-tabular=\endtabularx,
}

\usepackage{url}
\usepackage{amsopn} % For \newmcodes@ example

\usepackage{mathtools} % For \coloneqq

\usepackage{amsmath}
\DeclareMathOperator{\MyFunc}{my-func}

\usepackage{varioref}
\usepackage[sort&compress,capitalize]{cleveref}

\crefname{page}{page}{pages}
\crefname{equation}{Eq.}{eqs.}
\crefname{figure}{Fig.}{figs.}
\crefname{section}{Sect.}{sects.}

\usepackage{booktabs}

% Avoid stretching formulas:
% http://tex.stackexchange.com/questions/104127/
\thinmuskip=3mu
\medmuskip=4mu
\thickmuskip=5mu

\makeatletter

% Copied from http://ctan.uib.no/macros/latex/base/doc.dtx
% Protect when used in moving arguments.
{\catcode`\|=\z@ \catcode`\\=12 |gdef|bslash{\}}

\ExplSyntaxOn

\DeclareDocumentCommand \bigpar { } {
    \bigskip
    \par
    \noindent
    \@afterindentfalse
    \@afterheading
}

\DeclareDocumentCommand \textb { m } {
    {\fontseries{b}\selectfont #1}
}

\NewDocumentCommand \pkg { o m } {

    \IfNoValueTF { #1 } {
        % The literal colon has a different meaning with expl3 syntax
        \href{ https\c_colon_str//ctan.org/pkg/#2 }{ \textsf { #2 } }
    } {
        \href{ #1 }{ \textsf { #2 } }
    }

}

\NewDocumentCommand \codefont { m } {
    \texttt{ #1 }
}

\NewDocumentCommand \code { s m } {
    \tl_set:Nn \l_tmpa_tl { #2 }
    \IfBooleanT { #1 } {
        \regex_replace_all:nnN
            { \s+ }{ \c{textnormal}\cB\{ \0 \cE\} } \l_tmpa_tl
    }
    \codefont{ \l_tmpa_tl }
}

% https://tex.stackexchange.com/a/44362/18003
\DeclareTextFontCommand \hyphencodefont {
    \ttfamily \hyphenchar \font=45 \relax
}

\ExplSyntaxOff
\makeatother

\NewDocumentCommand \bootstrapped { s } {%
    This \IfBooleanT{#1}{version of the } command is only available inside the
    \refEnv*{pseudo} environment.%
}

\NewDocumentCommand \shortcutted { m m } {%
    If some package defines \cs{#1} before \pkg{pseudo} is loaded, \pkg{pseudo}
    will not overwrite it. The command will still be available, as \cs{#2}. To
    get the shorter version, simply use \code{\cs{let}\cs{#1}\cs{#2}}, possibly
    as part of the \refk{init} hook.%
}

\NewDocumentCommand \pseudoshortcutted { m } {%
    \shortcutted{#1}{pseudo#1}%

}

\NewDocumentCommand \novaluekey { } {%
    takes no value%
}

\NewDocumentCommand \initialkeyvalue { m } {%
    no default, initially #1%
}

\NewDocumentCommand \initiallyempty { } {%
    \initialkeyvalue{empty}%
}

\NewDocumentCommand \fontutil { m } {%
    This is a convenience for typesetting #1, and you may freely redefine it
    to whatever you prefer.%
}

\NewDocumentCommand \fontkey { m } {%
    Used to set \refc{#1font}, which is used as part of \refc{#1}. May be set
    to take a single argument or none. Not restricted to actual font commands;
    you may also mix in \cs{textcolor} or the like.%
}

\NewDocumentCommand \setandused{ m m }{%
    The command set by the \refk{#1} option. Used as part of \refc{#2}.%
}

\NewDocumentCommand \setandusedinit{ m m }{%
    The command set by the \refk{#1} option. Used as part of the initial value
    of \refk{#2}.%
}

\NewDocumentCommand \fontcmd { m } {%
    \setandused{#1font}{#1}%
}

\NewDocumentCommand \bracketing { m m m } {%
    Text or commands inserted at the #1 of a #2, when using
    \refc{#3}.%
}

\NewDocumentCommand \leftbracketing { m m } {%
    \bracketing{start}{#1}{#2}%
}

\NewDocumentCommand \rightbracketing { m m } {%
    \bracketing{end}{#1}{#2}%
}

\NewDocumentCommand \seealsostyle { m } {%
    See also \refc{#1}.  (Note that \cs{pseudo#1} is used internally here.)%
}

\NewExpandableDocumentCommand \tcolorboxstylepre { } {%
    \parindent1.5em
    \noindent
    A style defined for use with \pkg{tcolorbox} (i.e., not with
    \cs{pseudoset}).

    A simple, manually numbered example:
}

\NewExpandableDocumentCommand \tcolorboxstylepost { } {%
    To create a floating box, use the \pkg{tcolorbox} key \cs{float}. In
    general, it is probably better to create such boxes with \cs{newtcbtheorem}.
    For more information on using \pkg{tcolorbox} styles, see \cref{sec:floats}.

}

\NewExpandableDocumentCommand \tcolorboxstylenosource { m } {%
\begin{docKey}{pseudo/#1}{}{\pkg{tcolorbox} style}
    \parindent1.5em
    \noindent
    A style defined for use with \pkg{tcolorbox} (i.e., not with
    \cs{pseudoset}).
    A simple example:

\begin{tcolorbox}[pseudo/#1,
    title={Algorithm 1\enskip \pr{Hello}(x)}]
    \begin{pseudo}
        \kw{print} \st{Hello,} $x$
    \end{pseudo}
\end{tcolorbox}

    \noindent
    See the \refk{pseudo/boxed} reference entry and \cref{sec:floats} for more
    information.
\end{docKey}
}

\pgfqkeys {/tcb} {
    listing/.style = {
        listing only,
        before skip balanced=8pt plus 2pt minus 2pt,
        after app=\noindent
    }
}

\lstdefinestyle{tcblatex}{language={[LaTeX]TeX},
    columns=fullflexible,
    keepspaces=true,
    breaklines=true,
    breakatwhitespace=true,
    basicstyle=\ttfamily\small\color{black!80},
    extendedchars=true,
    nolol,
    inputencoding=\kvtcb@listingencoding,
    literate={\$}{\textcolor{black!65}{\$}}{1}%
    {~}{\textcolor{gray}{\raisebox{-.75ex}{\textasciitilde}}}{1},
    commentstyle=\color{gray},
}

\let\braces\brackets

\DeclareTCBListing{texexp}{ !O{} }{
    empty,
    arc=0pt,
    boxsep=0pt,
    overlay unbroken={
        \draw[black!50, xshift=0.5\pgflinewidth, semithick]
            ($(frame.north west)+(3pt,0)$) --
            +(-3pt,0) -- (frame.south west) -- +(3pt,0);
        \draw[black!50, xshift=-0.5\pgflinewidth, semithick]
            ($(frame.north east)+(-3pt,0)$) --
            +(3pt,0) -- (frame.south east) -- +(-3pt,0);
    },
    left=1.5em, % \parindent -- but that changes inside doc
    text above listing,
    before skip balanced=6pt plus 2pt minus 2pt,
    after skip balanced=8pt plus 2pt minus 2pt,
    after app=\noindent,
    % Because listings messes with the equals sign:
    before lower app={
        \RestorePseudoEq
    },
    #1
}

\tcbset{
    infobox/.style = {
        pseudo/filled,
        colback = black!4,
        colbacktitle = black!4,
        % coltitle = black!65,
        top = 9pt,
        bottom = 8pt,
        right= 10pt,
        left= 9pt,
    },
    admonition/.style = {
        infobox,
        borderline west = {2.5pt}{0pt}{black!25},
        leftrule = 2.5pt, % spacing
        before title = {},
        after title = {},
        attach title to upper,
        beforeafter skip balanced = 6.0pt plus 3.0pt minus 1.5pt,
    },
    sidebar/.style = {
        infobox,
        float,
        colback = white,
        colbacktitle = white,
        boxrule = \lightrulewidth,
        borderline = {\lightrulewidth}{0pt}{black},
        toptitle = 8pt,
        top = 5pt,
        fonttitle = \centering\bfseries\large,
    }
}

\DeclareTColorBox {note} { } {
    admonition,
    % title = {Note:\enskip}
}

\DeclareTColorBox {sidebar} { m } {
    sidebar,
    title = {#1},
}

\def\refc{\refCom*}
\def\refe{\refEnv*}
\def\refk{\refKey*}
\hyphenation{pseudo-code}

\title{The \textsf{pseudo} Package}
\author{Magnus Lie Hetland}

\colorlet{dimmed}{black!30}

\ExplSyntaxOn

\regex_const:Nn \c_var_regex {
    % \A
    ([lg]\c{lst@um_})
    (.+)
    (\c{lst@um_}
    (cs
    |clist
    |dim
    |fp
    |int
    |muskip
    |seq
    |skip
    |str
    |tl
    |bool
    |box
    |coffin
    |flag
    |fparray
    |intarray
    |iowr
    |iow
    |prop
    |regex))
    \Z
}
\regex_const:Nn \c_cmd_regex { : [NncVvoxefTFpw]* \Z }
\regex_const:Nn \c_pre_regex { @@\c{lst@um_} }

% Cf. https://tex.stackexchange.com/questions/402135
\NewDocumentCommand \DimmedAts { } {

    \tl_set:No \l_tmpa_tl {\the\use:c{lst@token}}

    \regex_replace_all:NnN
        \c_var_regex
        { \c{textcolor}\cB{ dimmed \cE}\cB{ \1 \cE}
            \2
          \c{textcolor}\cB{ dimmed \cE}\cB{ \3 \cE}
      } \l_tmpa_tl

    \regex_replace_all:NnN
        \c_pre_regex
        { \c{textcolor}\cB{ dimmed \cE}\cB{ \0 \cE} } \l_tmpa_tl

    \regex_replace_all:NnN
        \c_cmd_regex
        { \c{textcolor}\cB{ dimmed \cE}\cB{ \0 \cE} } \l_tmpa_tl

    \tl_use:N \l_tmpa_tl
    \use_none:n

}


\NewDocumentCommand \Abstract { } {

    \ior_open:Nn \g_tmpa_ior {README.md}

    \tl_gclear:N \g_tmpa_tl

    \ior_map_inline:Nn \g_tmpa_ior {

        % Skip the first paragraph
        \regex_match:nnT { ##1 } { \c{par} } {
            \ior_map_break:
        }

    }

    \ior_map_inline:Nn \g_tmpa_ior {

        % Just using the next paragraph
        \regex_match:nnTF { ##1 } { \c{par} } {
            \ior_map_break:
        } {
            \tl_gput_right:Nn \g_tmpa_tl { ##1 }
        }

    }

    \regex_replace_all:nnN
        {\*\* ( \w+ ) \*\*}
        { \c{pkg} \cB{ \1 \cE} } \g_tmpa_tl

    \regex_replace_all:nnN
        {` ( \w+ ) `}
        { \c{hyphencodefont} \cB{ \1 \cE} } \g_tmpa_tl
    %   { \c{code} \cB{ \1 \cE} } \g_tmpa_tl

    \tl_use:N \g_tmpa_tl

    \ior_close:N \g_tmpa_ior

}

\ExplSyntaxOff

\makeatletter
\DeclareTCBListing{source}{ !O{} }{
    empty,
    breakable,
    listing only,
    arc=0pt,
    boxsep=0pt,
    left=\parindent,
    top=0pt,
    bottom=0pt,
    beforeafter skip balanced=\bigskipamount,
    after app=\noindent,
    #1
}
\makeatother

% Doesn't work:
% \usepackage{noindentafter}
% \NoIndentAfterEnv{source}

\newtcbtheorem[
        number within = chapter,
        crefname = {Algorithm}{algorithms}
    ]%
    {algorithm}{Algorithm}{pseudo/ruled}{alg}

\newtcbtheorem[
        use counter from = algorithm,
        crefname={Algorithm}{algorithms}
    ]%
    % {internalpseudobox}{Algorithm}{float}{pbx}
    {internalpseudobox}{Algorithm}{}{pbx}

\usepackage{ellipsis}

\begin{document}


\makeatletter
{\colorlet{scol}{black!15}%
\def\ssep{\hspace{.5em}\color{scol}}%
\absput[scale=4.5]{
    \tcbox[
        pseudo/boxruled,
        before upper={}, % bc/o restricted horizontal mode
        after upper={},  % -- " --
        title={pseudo \pseudoversion\textcolor{scol}{\pseudorevision}}]
    {%
    \begin{pseudo}[hsep=.5em, label=\color{sred}\arabic*]
    \rlap{straight-}\phantom{pseudocode}\ssep\code{\bslash\bslash+}\\
    \phantom{pseudocode}\llap{forward}\ssep\code{\bslash\bslash-}\\
    pseudocode\ssep\code{\bslash\bslash}
    \end{pseudo}%
    }
}}
\makeatother

\pagenumbering{roman}
\pagestyle{empty}
\pagecolor{black!4}
\null
\clearpage
\null\vfill
{\small
\makeatletter
\noindent
Copyright\enskip\copyright\enskip\@author\enskip2019--\the\year
\makeatother

\medskip\noindent
\Abstract}
\clearpage
\nopagecolor

\pagenumbering{arabic}

\begin{titlepage}
\makeatletter
\null
\begin{center}

\null
\vfill

\Huge
\@title

\vspace{\baselineskip}

\LARGE
\@author

\vspace{\baselineskip}

\LARGE
\@date

\vfill

\end{center}
\makeatother
\end{titlepage}

\tableofcontents

\pagestyle{fancy}

\chapter{Introduction}

The \pkg{pseudo} package lets you typeset pseudocode in a straightforward and
not all too opinionated manner. You don't need to use separate commands for
different constructs; the indentation level is controlled in a manner similar
to in a \code{tabbing} environment:

\label{p:intro-euclid}
{
\pseudoset{kw}
\begin{texexp}
\begin{pseudo}
    while $a \neq b$                            \\+
        if $a > b$                              \\+
            $a = a - b$                         \\-
        else $b = b - a$                        \\-
    return $a$
\end{pseudo}
\end{texexp}
}%
%
If you prefer having \kw{end} at the end of blocks, or you'd rather wrap them
in C-style braces, you just put those in. Fonts, numbering, indentation
levels, etc., may be configured. You import \pkg{pseudo} with:
\begin{center}
\code{\cs{usepackage}[\meta{options}]\braces{pseudo}}
\end{center}
The only option usable here at the moment is \refk{kw} (used in the example
above), as the \cs{usepackage} command is a bit too eager in expanding its
arguments, but there are several options that may be provided to the
\refc{pseudoset} command, to configure things (see \cref{sec:cmdandkeyref}).
For a more complete example, see \cref{alg:euclid}.

{
\pseudoset{kw}
\TabPositions{1.5cm}
% Duplicated in example, below, without [float]:
\begin{algorithm}[float]{Euclid's algorithm, \pr{Euclid}(a, b)}{euclid}

\textbf{Input:}  \tab Two positive integers, $a$ and $b$.

\textbf{Output:} \tab The greatest common divisor of $a$ and $b$.

\begin{pseudo}[label=\small\arabic*, indent-mark, fullwidth]

    while $a \neq b$      &  If equal, both are gcd           \\+
        if $a > b$        &  Reduce max with multiple of min  \\+
            $a = a - b$   &  $a$ is largest                   \\-
        else $b = b - a$  &  $b$ is largest                   \\-
    return $a$            &  Both are gcd, so return one
%
\end{pseudo}

The running time is quadratic in the number of bits in the input.

\end{algorithm}
}

\section*{Microtutorial: How to produce \cref{alg:euclid}}

The pseudocode in \cref{alg:euclid} is typeset in the same way as on
\vpageref{p:intro-euclid}. The line numbers are styled using the \refk{label}
key, the vertical lines are produced by the \refk{indent-mark} option, and the
comments are just a separate column of a \code{tabularx}, which is used instead
of the built-in \code{tabular}, as explained in
\cref{sec:tabularx}.\footnote{That is, the \code{fullwidth} style that is
defined \vpageref{p:fullwidth} is used in this example.} To get the surrounding
ruled box, a \pkg{tcolorbox} is used, with the style \refk{pseudo/ruled}. This
has been set up with a predefined box environment, \code{algorithm}, which is
defined in \cref{sec:floats} (\vpageref{p:pseudo-ruled-def}). The \refc{pr}
command and its relatives (as well as most other functionality) are discussed in
\cref{sec:overview}, with individual definitions given in
\cref{sec:reference}.\footnote{The actual implementations, with explanations,
are found in \cref{sec:impl}.} The input and output descriptions are aligned
using \cs{tab} from the \pkg{tabto} package (cf.\@
\cref{sec:tabstops}).

\begin{texexp}[listing]
% In document preamble:
% \usepackage{tabto}
% \TabPositions{1.5cm} % Adjust as needed!

\begin{algorithm}{Euclid's algorithm, \pr{Euclid}(a, b)}{euclid}

\textbf{Input:}  \tab Two positive integers, $a$ and $b$.

\textbf{Output:} \tab The greatest common divisor of $a$ and $b$.

\begin{pseudo}[label=\small\arabic*, indent-mark, fullwidth]
    while $a \neq b$      &  If equal, both are gcd           \\+
        if $a > b$        &  Reduce max with multiple of min  \\+
            $a = a - b$   &  $a$ is largest                   \\-
        else $b = b - a$  &  $b$ is largest                   \\-
    return $a$            &  Both are gcd, so return one
\end{pseudo}

The running time is quadratic in the number of bits in the input.

\end{algorithm}
\end{texexp}

\begin{note}
With a different font, ``\textb{Output:}''\ may take up more space, and
\cs{tabto} might just introduce a line break. If so, simply increase the
argument to \cs{TabPositions}. To produce an indent right after a line break
(\cs{\bslash})---e.g., if you want multiline input/output---use
\cs{null}\cs{tab}.
\end{note}

\section*{Alternatives}

There are many ways of typesetting code and pseudocode in \LaTeX, so if you're
unhappy with \pkg{pseudo}, you have several alternatives to choose from. I
wrote \pkg{pseudo} based on my needs and preferences, but yours may differ, of
course. For example, I've built on tabular layouts to get
\begin{inl}
\item automatic width calculations;
\item line/row highlighting; and
\item easy embedding in \pkg[https://ctan.org/pkg/pgf]{tikz} nodes and the
like.
\end{inl}
I have also set things up inspired by existing mechanisms for numbering and
indenting lines, and treat the pseudocode as a form of text, rather than as a
form of markup in itself. The latter point means that I don't have separate
commands for conditionals, loops, etc.

The basic style of pseudocode is inspired by the standard reference
\emph{Introduction to Algorithms} by \citet{Cormen:2009} (i.e., similar to
that of \pkg{newalg},
\pkg[https://ctan.org/tex-archive/macros/latex/contrib/clrscode]{clrscode} and
\pkg{clrscode3e}).
%
Rather than locking down all aspects of pseudocode appearance, however, I've
tried to make \pkg{pseudo} highly configurable, but if it's not flexible
enough, or just not to your liking, you might want to have a look at the
following packages:

\begin{quote}
    \raggedright
    \pkg[https://ctan.org/tex-archive/macros/latex/contrib/alg]{alg},
    \pkg{algobox},
    \pkg{algorithm2e},
    \pkg{algorithmicx},
    \pkg{algorithms},
    \pkg{algpseudocodex},
    \pkg{algxpar},
    \pkg[https://ctan.org/tex-archive/macros/latex/contrib/clrscode]{clrscode},
    \pkg{clrscode3e},
    \pkg[https://www.cs.dartmouth.edu/~thc/]{clrscode4e},
    \pkg[https://github.com/esneider/latex-pseudocode]{latex-pseudocode},
    \pkg{newalg},
    \pkg[https://ctan.org/tex-archive/macros/latex/contrib/program]{program},
    \pkg[https://ctan.org/tex-archive/macros/latex/contrib/pseudocode]{pseudocode}
\end{quote}

\noindent
There are also code-typesetting packages like
\pkg[https://ctan.org/tex-archive/macros/latex/contrib/listings]{listings} and
\pkg{minted}, of course.

\section*{Using older \TeX\ distributions}

The imlementation of \pkg{pseudo} uses some functionality that isn't available
in older \TeX\ distributions, in particular, older versions of \pkg{xparse} and
\pkg{expl3}. Some care has been taken to make the code backward compatible to
the point where it works on \TeX\ Live~2020, which is what is used (at the time
of writing) on \href{https://arxiv.org}{arXiv}. If you run into issues somewhere
else (e.g., when submitting to some publisher with a custom setup), feel free to
\href{https://github.com/mlhetland/pseudo.sty/issues}{file an issue}, or even
\href{https://github.com/mlhetland/pseudo.sty/pulls}{provide a pull request}
with a fix. One thing to look out for is that older versions of \pkg{xparse}
parse arguments differently, so things like
\code{\cs{\bslash}[hl]}
% \begin{texexp}[listing]
% foo\\<1>
% bar\\[hl]
% \end{texexp}
would work, but separating the arguments with spaces, as in
% \begin{texexp}[listing]
% foo\\ <1>
% bar\\ [hl]
% \end{texexp}
\code*{\cs{\bslash} [hl]}
will \emph{not} work, though this works with more recent versions (as seen
from some of my examples, later).
\begin{note}
For more advice on working around an older distribution, see \cref{sec:older}.
\end{note}

\chapter{Pseudocode}
\label{sec:overview}

The main component of the \pkg{pseudo} package is the \refe{pseudo}
environment, which is, in a sense, a hybrid of \code{enumerate},
\code{tabular} and \code{tabbing}, in that it provides numbered lines, each
placed in a tabular row (for ease of highlighting and automatic column width
calculation), with functionality for increasing and decreasing indentation
similar to the \code{tabbing} commands \cs{+} and \cs{-} (in \pkg{pseudo},
combined with the row separator \refc{\bslash}). Here, once again, is
Euclid's algorithm for finding the gcd of $a$ and $b$:

\begin{texexp}
\begin{pseudo}
repeat the following while $a\neq b$            \\+
    if $a > b$, let $a = a - b$                 \\
    otherwise, let $b = b - a$
\end{pseudo}
\end{texexp}

% \medskip
\noindent
There are also some styling commands for special elements of the pseudocode:

\begin{texexp}
\kw{while},          % or \pseudokw    -- keywords
\cn{false},          % or \pseudocn    -- constants
\id{rank},           % or \pseudoid    -- identifiers
\st{Hello!},         % or \pseudost    -- strings
\pr{Euclid}(a, b),   % or \pseudopr    -- procedures
\fn{length}(A),      % or \pseudofn    -- functions
\ct{Important!}      % or \pseudoct    -- comments
\end{texexp}
%
The longer names (\cs{pseudokw}, \cs{pseudocn}, etc.)\@ are always available;
the more convenient short forms (\refc{kw}, \refc{cn}, etc.)\@ are prone to
name collisions, and are only defined if the names are not already in use when
\pkg{pseudo} is imported.

Spacing is handled similarly to in \LaTeX\ lists, with \cs{topsep} and
\cs{parskip} added before and after, as well as \cs{partopsep} whenever the
environment starts a new paragraph. The left margin (how much the pseudocode
is indented wrt.\ the surrounding text) is set by the \refk{left-margin} key
(initially \code{0pt}).

\begin{note}
If \refe{pseudo} occurs in a box such as \code{fbox}, or
a \pkg[https://ctan.org/pkg/pgf]{tikz} node, this spacing is dropped. See also
the \refk{compact} key for overriding this behavior.
\end{note}

The \refk{indent-length} option, which determines the length of each
indentation step, is initially set via the secondary \refk{indent-text} key,
so that the any code after \code{\cs{kw}\braces{else}} aligns with the
indented text (a stylistic choice from \pkg{clrscode3e}):
\begin{texexp}
\begin{pseudo}
\kw{if} $x < y$                                 \\+
    $x = x + 1$                                 \\-
\kw{else} $x = x - 1$
\end{pseudo}
\end{texexp}
%
\label{p:indent-mark}%
The indentation may also be configured with \refk{indent-mark}, which inserts a
mark at every indenation step:
\begin{texexp}
\begin{pseudo}[indent-mark]
    while $x\leq n$                             \\+
        $x = x + 1$                             \\
        if $f(x) < y$                           \\+
            $x = x + 1$                         \\-
        print $x$                               \\-
    return $x$
\end{pseudo}
\end{texexp}
The default is a vertical line, but anything else may be supplied as an
argument. To avoid adding to the indentation, you can wrap this argument in
\cs{rlap}.\footnote{If your mark is very tall, and you don't wish it to increase
the line height, you could also wrap it in \cs{smash}.} The color may be
modified using \refk{indent-mark-color}:
\begin{texexp}
\begin{pseudo}[
    indent-mark=\rlap{$\triangleright$}, indent-mark-color=teal]
    while $x\leq n$                             \\+
        $x = x + 1$                             \\
        if $f(x) < y$                           \\+
            $x = x + 1$                         \\-
        print $x$                               \\-
    return $x$
\end{pseudo}
\end{texexp}
%
The default indent mark scales with the line height, which can be adjusted with
\refk{line-height} and \refk{extra-space}, to avoid gaps in the vertical lines,
and its width has no impact on the indentation. The width of the (default) mark
can be set with \refk{indent-mark-width}:\footnote{You can also shift the
default mark inward by setting \refk{indent-mark-shift}.}
\begin{texexp}
\begin{pseudo}[
    indent-mark, indent-mark-width=3pt, line-height=1.5]
    the                                         \\+
        lines                                   \\+[3ex]
            are                                 \\-
        scaled
\end{pseudo}
\end{texexp}
%
Note here how some extra space is specified using the optional argument
\code{3ex} with \refc{\bslash}. This is equivalent to explicitly setting the
key \refk{extra-space} (i.e., in this case,
\code{\cs{\bslash}+[extra-space=2ex]}).

If you want, you can certainly create shortcuts, e.g., with simple macro
definitions like \verb|\def\While{\kw{while}}|, or with declaration commands such
as \refc{DeclarePseudoKeyword} or \refc{DeclarePseudoConstant}. Procedures and
functions capture parenthesized arguments and set them in math mode; this
carries over in shortcuts, so if you define \verb|\Euclid| to mean
\verb|\pr{Euclid}|, then \code*{\cs{Euclid}(a, b)} yields
\pr{Euclid}(a,b).\footnote{Note that \code*{\cs{Euclid} (a, b)}, with a space
before the parenthetical, yields \pr{Euclid} (a, b).}

These commands are not used in the internals of the package, so they may be
freely redefined for different styling, such as \verb|\let\id\textsf|. They
generally do some extra work, though, such as wrapping the styled text in
\cs{textnormal} to avoid having the styles blend, adding quotes (\cs{st}) and
handling parenthesized arguments (\cs{pr}). To let you hook into their
appearance without messing with their definitions, each command has a
corresponding font command (\cs{kwfont}, \cs{cnfont}, \cs{idfont}, etc.),
which you may redefine. These fonts may even be set using correspondingly
named options, either with \refc{pseudoset} or via optional keyword arguments
to the \refe{pseudo} environment:\footnote{Because of \LaTeX\ expansion
behavior, they can \emph{not} be set globally when importing \pkg{pseudo}.}
\begin{texexp}
\pseudoset{prfont=\textsf}
Euclid's algorithm is initiated with the call \pr{Euclid}(a, b).
\end{texexp}
\noindent
You can also configure the quotes and comment markers:
\begin{texexp}
\pseudoset{
    st-left=`, st-right=', stfont=\textit,
    ct-left=\texttt{/\!/}\,, ct-right=, ctfont=
}
\begin{pseudo}
\kw{print} \st{Hello, world!} \quad \ct{Greeting}
\end{pseudo}
\end{texexp}

\begin{note}
Note that \cs{stfont} and friends may either be font-switching commands like
\cs{itshape} or formatting commands like \cs{textit}, though the latter are
generally preferable when available. They need not be restricted to actual
fonts, but may include color commands, for example.
\end{note}

You can also set the font for the entire code lines, using the \refk{font}
option. The command you provide there should just switch the font (i.e., not
take an argument to typeset); initially, \cs{kwfont} is such a command:

\begin{texexp}
\begin{pseudo}[font=\kwfont]
while $a \neq b$                                \\+
    if $a > b$                                  \\+
        $a = a - b$                             \\-
    else $b = b - a$
\end{pseudo}
\end{texexp}

\noindent
Though not the default, this is in fact an intended configuration, to reduce
the markup noise for pseudocode that consists primarily of keywords and
mathematics. The setting \code*{\refk{font} = \refc{kwfont}} is also available
by using the \refk{kw} option (with no arguments), e.g., by importing the
package with \verb|\usepackage[kw]{pseudo}|. If you need to typeset normal
text in your pseudocode after using \refk{font}, you can use \cs{textnormal}
or \cs{normalfont}, for which \pkg{pseudo} defines aliases \refc{tn} and
\refc{nf}:

\begin{texexp}
\begin{pseudo}[kw]
for \tn{each node} $v\in V$                     \\+
    \tn{do something}                           \\-
for \nf each edge $e \in E$                     \\+
    \nf do something else
\end{pseudo}
\end{texexp}

\noindent
The row separator may have multiple pluses or (more commonly) multiple minuses
appended, indicating multiple increments or decrements to the indentation
level:

\begin{texexp}
\begin{pseudo}[kw]
for $k = 1$ to $n$                              \\+
for $i = 1$ to $n$                              \\+
for $j = 1$ to $n$                              \\+
$t_{ij} = t_{ij} \lor (t_{ik} \land t_{kj})$    \\---
return $t$
\end{pseudo}
\end{texexp}
%
The code is normally typeset in a two-column \code{tabular} (whose preamble,
and thus number of columns, is configurable via the option \refk{preamble}),
but the first column is handled by an automatic \refk{prefix} inserted before
each line, containing the numbering and column separator (\code{\&}). You
disable the prefix for the following line by using \code{\refc{\bslash}*}. If
you add the \code{\&} manually, you get an (appropriately indented) unnumbered
line:

\begin{texexp}
\begin{pseudo}
  this line has an automatic prefix             \\+*&
  this line does not                            \\+
  but this one does
\end{pseudo}
\end{texexp}

\noindent
The \code{\cs{\bslash}*\&} combo can also be used for manual line breaking in
multiline pseudocode steps:

\begin{texexp}
\begin{pseudo}[indent-mark]
Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam
nonumy \\*& eirmod tempor invidunt ut labore et dolore magna
aliquyam erat. \\+
At vero eos et accusam et justo duo dolores et ea rebum. Stet
clita \\*& kasd gubergren, no sea takimata sanctus est Lorem ipsum
dolor.
\end{pseudo}
\end{texexp}

\begin{note}
Automatic line wrapping is a bit trickier. See \cref{sec:multiline} for a
discussion.
\end{note}

\noindent
This star also works after \code{\cs{begin}\braces{pseudo}}. Note that in
order to prevent your code from ending up in the numbering column, you must
insert a column separator manually. A version of the \refc{pr} command, called
\refc{hd} (or \cs{pseudohd}, where \refc{hd} stands for \emph{header}) instead
wraps a procedure call in a \code{multicolumn}, so it can be used, for
example, as an unnumbered header line:\footnote{See also \refk{hd-space}, if you
want some extra space after the header.}

\begin{texexp}
\begin{pseudo}[kw]*
\hd{Euclid}(a, b)                               \\
if $b \== 0$                                    \\+
    return $a$                                  \\-
    else return \pr{Euclid}(b, a \bmod b)
\end{pseudo}
\end{texexp}

\begin{note}
The \refc{hd} command is less capable than \refc{pr} and \refc{fn} in its
argument parsing: the parenthetical arguments are mandatory, and they are
terminated at the first closing parenthesis, regardless of nesting. If you want
to include parentheses in the arguments, you need to wrap them in braces, e.g.,
\code{\cs{hd}\braces{Traverse}(\braces{G=(V, E), s})}.
\end{note}

Another style is to include the header as a statement, just as any other,
perhaps with an introductory keyword. The following example, for example, is
based on one in the \pkg{algxpar} documentation (using \refe{pseudo*} to
suppress line numbering, along with a couple of config keys):

\let\origbf\bf
\def\bf{\fontseries{bx}\selectfont}
\begin{texexp}
\begin{pseudo*}[font=\bf, indent-length=1.5em]
function \pr{Max}(a, b)                         \\+
    if $a > b$ then                             \\+
        return $a$                              \\-
    else                                        \\+
        return $b$                              \\-
    end if                                      \\-
end function
\end{pseudo*}
\end{texexp}
\let\bf\origbf

As can be seen in the earlier \pr{Euclid} example, \cs{==} (or \refc{eqs}) is
a notational convenience defined by \pkg{pseudo}, along with interval dots
\cs{..}\@ (or \refc{dts}) and the alternative range operator \refc{rng}:
\begin{texexp}
Do you prefer $A[1 \.. n]$ or $A[1 \rng n]$?
\end{texexp}

\begin{sidebar}{Shortcuts for \cs{rng}}
The \refc{..}\@ command is actually implemented by hijacking the \cs{.}\@
command, and isn't easily redefined directly. Instead, if you want
\code{1\refc{..}n} to produce $1\rng n$, you can use the \refk{dts-impl} key
(i.e., \code*{\refk{dts-impl} = \refc{rng}}).

Another option is to introduce some other shortcut, such as \cs{:}, for example:
\begin{texexp}
\let\:\rng
$A[1\:n]$
\end{texexp}
Note that \cs{:}\@ is an existing spacing command that produces a medium space.
If \cs{:}\@ is redefined, this spacing command is still available as \cs{>}.
However, if you use packages that rely on \cs{:}, such a redefinition might
cause trouble. One solution is to keep the redefinition local, e.g., using
\code*{\refc{pseudoset}\braces{\refk{init} = \cs{let}\cs{:}\refc{rng}}}.
\end{sidebar}

\noindent
Other special symbols may be found in other packages. For example, if you want
to use $\coloneqq$ for assignment, you can use \cs{coloneqq} from
\pkg{mathtools} (perhaps with \verb|\let\gets\coloneqq|).\footnote{Tip: If you
want to use a left-arrow for assignment, but think it's a bit large in Computer
Modern or Latin Modern, you can use the
\pkg[https://ctan.org/tex-archive/fonts/old-arrows]{old-arrows} package,
so \code*{x \cs{gets} y} yields $x\gets y$.}

As can be seen, one use of \code{\refc{\bslash}*} is to get an unnumbered
line, but you could also insert custom material in the first column.
%
The lines are numbered by the counter \code{pseudoline}, so you could, for
example, do:

\begin{texexp}
\begin{pseudo}*
\stepcounter{pseudoline}\Alph{pseudoline} & Look! \\*
\stepcounter{pseudoline}\Alph{pseudoline} & We're using letters!
\end{pseudo}
\end{texexp}

\noindent
This is a bit cumbersome, so there are some shortcuts. First of all, rather
than replacing the entire \refk{prefix}, you can replace only a \emph{part} of
it, namely the \refk{label}, retaining counter increments and column
separators. You can set this key for each line individually with an optional
argument to the row separator, i.e.,
\code*{\refc{\bslash}[\refk{label} = \meta{commands}]}, or at some higher
level. Within the \refe{pseudo} environment, there is also a counter named
\code{*} that is simply a local clone of \code{pseudoline}, letting you use
starred versions of counter commands, similarly to how label definitions work
in \pkg{enumitem}:\footnote{Also like in \pkg{enumitem}, there's a \refk{start}
key for setting the first line number.}

\begin{texexp}
\pseudoset{label=\small\arabic*:}
\begin{pseudo}
Look! \\
We're using something custom! \label{custom-line}
\end{pseudo}
\end{texexp}

\noindent
Note that if you refer to the labeled line with \cs{ref}, you'll just end up
with \ref{custom-line}, which is probably what you'd want in this case. If you
want a custom reference format as well, you can set that with the \refk{ref}
key, in the same way as with \refk{label}. If you use the key without arguments,
it'll use the same format as the one provided to \refk{label}:

\begin{texexp}
\pseudoset{label=(\textit{\roman*}), label-align=l, ref}
\begin{pseudo}
Look! \\
We're using Roman numerals! \label{roman-line} \\
And here's a reference to line \ref{roman-line}.
\end{pseudo}
\end{texexp}
%
The \refk{label-align} key sets the alignment of the label column, and can be
\code{l}, \code{r} or \code{c} (or really any other column type compatible
with the \pkg{array} package; you could use a \code{p\braces{\dots}} column to
get fixed width, for example).

Highlighting can also be done in a similar manner, by, e.g., inserting a
\cs{rowcolor} at the start of the first column. Rather than doing this
manually, you could use the \refk{bol} key, which inserts a command at the
beginning of the line---or the \refk{hl} key, which is equivalent to
\code*{\refk{bol-prepend} = \refc{pseudohl}}:

{
\pseudoset{hl-warn=false}%
\begin{texexp}
\begin{pseudo*}
I'm not highlighted \\[hl]
But I am!
\end{pseudo*}
\end{texexp}
}%
%
Initially, the \refc{pseudohl} command that is inserted is simply a
\cs{rowcolor} that uses \refk{hl-color}, but you're free to redefine this
command to whatever you'd like.

In the previous example, there is no spacing to the sides of the table
contents. This is normally what you'd want, for example, to keep the
pseudocode aligned with the surrounding text. However, when using row
highlighting (e.g., because you are stepping through the code in some
presentation), that alignment may be less of an issue---and you'd rather widen
the highlight a bit. The horizontal padding on each side is controlled by the
\refk{hpad} key.

\begin{note}
If you use \refk{hl} without \refk{hpad}, you'll get a warning. You can turn
this warning off using \refk{hl-warn} or by setting \refk{hpad} to \code{0pt}.
\end{note}

\noindent
You can either specify a length, or just turn on the default, by not supplying
an argument. There's a similar option, \refk{hsep}, which controls the
separation between the two columns.

\begin{texexp}
\begin{pseudo}[hpad, hsep=1em, indent-length=1em]
    let's                                       \\+
        use                                     \\-
    some                                        \\+ [hl]
        padding!
\end{pseudo}
\end{texexp}

\noindent\label{p:overlays}%
For ease of use with \pkg{beamer}, the various \pkg{pseudo} options support
\pkg{beamer} overlay specifications. For example, using \code{\refk{hl}<1>}
means that the \refk{hl} specification would only take effect on slide~1. If you
use such an overlay specification on a key when \emph{not} using beamer, the key
is simply ignored.

What is more, the row separator \emph{itself} takes an overlay specification
as a shortcut for the one on \refk{hl}, so \code{\refc{\bslash}<1,2-4>} is
equivalent to \code{\refc{\bslash}[\refk{hl}<1,2-4>]}.

\begin{note}
Actually, explicitly using \code{\refk{hl}<1,2-4>} wouldn't work! The problem is
that the key--value lists are split at commas before individual keys (including
overlay specifications) are parsed. And unlike values, using braces to
``protect'' the keys isn't entirely straightforward. The solution is instead to
use the key multiple times, as in
\code{\refc{\bslash}[\refk{hl}<1>, \refk{hl}<2-4>]}.
\end{note}

Just like with the optional arguments, space before the overlay specification is
ignored, so you're free to put the specification in front of the line in
question:

\medskip

\noindent
\includegraphics[page=1]{hilitefig.pdf}\hfill
\includegraphics[page=2]{hilitefig.pdf}\hfill
\includegraphics[page=3]{hilitefig.pdf}\hfill
\includegraphics[page=4]{hilitefig.pdf}

\vspace{-4pt}

% ! Copied from Beamer file
\begin{texexp}[listing only]
% In a beamer presentation
\begin{pseudo}[hpad]
    <1>  Go to line 3                           \\
    <3>  Go to line 4                           \\
    <2>  Go to line 2                           \\
    <4>  Go to line 1                           \\
\end{pseudo}
\end{texexp}
%
You might have expected these overlay specifications to indicate
\emph{visibility}, as they do for the \cs{item} command in \cs{enumerate}, for
example. However, in stepwise animations, highlighting patterns (showing which
line is currently executed, for example) tend to be more complex than, say, a
gradual uncovering---and therefore in greater need of abbreviation.

\label{p:pause}%
To control visibility, you could, for example, add \cs{pause} at the end of
each line, before the row separator. You can also do this using the \refk{eol}
key, either per line or at the top level, with \code*{\refk{eol} =
\cs{pause}}. There is even the shortcut key \refk{pause} for this specific
purpose (equivalent to \code*{\refk{eol-append} = \cs{pause}}):

\medskip

\noindent
\includegraphics[page=1]{pausefig.pdf}\hfill
\includegraphics[page=2]{pausefig.pdf}\hfill
\includegraphics[page=3]{pausefig.pdf}\hfill
\includegraphics[page=4]{pausefig.pdf}\qquad\null

\vspace{-4pt}

% ! Copied from Beamer file
\begin{texexp}[listing only]
% In a beamer presentation
\setbeamercovered{transparent}
\begin{pseudo}[pause]
    Eeny                                        \\
    Meeny                                       \\
    Miny                                        \\
    Moe                                         \\
\end{pseudo}
\end{texexp}
%
The \refk{eol} value is only inserted wherever \refc{\bslash} starts a new
line (i.e., not at the end of the environment), so in this case only three
\cs{pause} commands are inserted.

\begin{note}
    The last \refc{\bslash} looks for an immediately following
    \code{\cs{end}\braces{pseudo}}, after skipping any non-paragraph whitespace,
    so if you insert anything between the the \refc{\bslash} and
    \code{\cs{end}\braces{pseudo}}, even if it's just an empty line (i.e., a
    \cs{par}), you'll end up with an extra (empty) line in the result. Note,
    however, that the last \refc{\bslash} is entirely optional!
\end{note}

The previously discussed configuration keys are described in more detail in
\cref{sec:reference}. You can create your own presets or \emph{styles} using
\refc{pseudodefinestyle}. This command takes two arguments; the first is the
name of a key, and the second is a key--value list, as you would have supplied
it to \refc{pseudoset}. This is exactly how the \refk{starred} style is
defined (see~\cpageref{p:starred}), clearing the prefix and reducing the
preamble to a single column. This style is what's used in the starred,
unnumbered version of the \refe{pseudo} environment:
{
\pseudoset{kw}
\begin{texexp}
\begin{pseudo*}
    while $a \neq b$                            \\+
        if $a > b$                              \\+
            $a = a - b$                         \\-
        else $b = b - a$                        \\-
    return $a$
\end{pseudo*}
\end{texexp}
}

\chapter{Boxes and floats}
\label{sec:floats}

\begin{sidebar}{The short story}
First import \pkg{tcolorbox}, with
libraries \code{skins} and \code{theorems} (see nearby sidebar), and then put
the following in your preamble:
\begin{texexp}[listing]
\newtcbtheorem{algorithm}{Algorithm}{pseudo/ruled, float}{alg}
\end{texexp}
You now have an \code{algorithm} float with the \code{pseudo/ruled} style. The
environment takes two arguments: the title and a label name, which can be left
empty.
\end{sidebar}

There are (at least) two different ways of viewing a block of pseudocode: as
an inline element, like equations, or as a float, like figures and tables. For
example, \citet{Cormen:2009} place their pseudocode inline, and refer to the
algorithms by name (e.g., ``\pr{Dijkstra}''), while \citet{Williamson:2011} place
them in floats, and refer to them by number (e.g., ``Algorithm~3.1'').%
\footnote{A third option that is sometimes used is to use a theorem-like
environment for your algorithms. There are many packages to help with this;
just search \href{https://ctan.org}{\textsc{ctan}} for
``\href{https://ctan.org/search/?phrase=theorem}{theorem}''.}

Just using the \refe{pseudo} environment is sufficient for typesetting
pseudocode as part of the body text. If you wish to place your pseudocode in a
float, you can easily use a package such as
\pkg[https://ctan.org/tex-archive/macros/latex/contrib/float]{float}.\footnote{Or
you could do a quick \href{https://ctan.org}{\textsc{ctan}} search for
``\href{https://ctan.org/search/?phrase=float}{float}'', or take a look at the
\href{https://ctan.org/recommendations/float}{recommendations} related to
the \pkg[https://ctan.org/tex-archive/macros/latex/contrib/float]{float}
package, which will give you many options, with varying functionality.} You
could also use the float environments supplied with packages such as
\pkg{algorithms}, \pkg{algorithmicx} and \pkg{algorithm2e}.

\begin{note}
The definition of \refc{==} doesn't properly carry over into floats. It's
properly redefined inside \refe{pseudo}, so you probably won't notice, but if
you wish to use the symbol outside the \refe{pseudo} environment, but in a float
(e.g., inside \cs{caption}), you'll need to either call \refc{RestorePseudoEq}
to re-establish \pkg{pseudo}'s redefinition of \cs{=} or simply use \refc{eqs}
instead of \refc{==}.
\end{note}

\noindent
The \pkg{pseudo} package does provide some specialized setup,
however, using \pkg{tcolorbox}. This also lets you typeset non-float pseudocode
with a colored background, for example, like \citeauthor{Cormen:2022} do in the
most recent version of their textbook~\citep{Cormen:2022}.
%
\begin{sidebar}{Importing \pkg{tcolorbox}}
For performance reasons, \pkg{pseudo} does \emph{not} automatically import
\pkg{tcolorbox}; if you want to use the box functionality, you will need to
import it yourself:
\begin{texexp}[listing]
\usepackage{pseudo}
% ...
\usepackage{tcolorbox}          % possibly with options
\tcbuselibrary{skins,theorems}  % remember these
\end{texexp}
It does not matter whether you import
\pkg{tcolorbox} before or after \pkg{pseudo}, but make sure you also import the
two libraries \code{skins} and \code{theorems}, as in the example above.
\end{sidebar}
%
The styles defined by \pkg{pseudo} are versions of the commonly used
\emph{boxed} and \emph{ruled} styles, as found in, e.g.,
\pkg[https://ctan.org/tex-archive/macros/latex/contrib/float]{float}, as well as
the \emph{boxruled} and \emph{tworuled} styles found in \pkg{algorithm2e}. In
addition, there's a \emph{filled} style, with a colored background. If you wish
to customize and extend the box style, \refk{pseudo/boxruled} is probably the
best starting point, as the other styles disable the default frame drawing.

The ruled style is one of the more common ones in  use in publications. This is
a style originally used for (non-floating) tables in \emph{Concrete
Mathematics}~\citep{Graham:1994}. Rather than reproducing the look of those
tables directly, \pkg{pseudo} aims to match the style of \pkg{booktabs}, with
spacing and line thicknesses taken from its constants such as \cs{aboverulesep},
\cs{heavyrulewidth}, etc.\@ (with defaults provided if \pkg{booktabs} has not
been imported).\footnote{In \pkg{booktabs}, the contents between the top rules
make up the header row, whereas in the \emph{Concrete Mathematics} style, it's
the caption.} The \refk{pseudo/booktabs} style uses the same pattern of thin and
thick lines as \pkg{booktabs} tables, while \refk{pseudo/ruled} uses a thin line
at the bottom, as in the \emph{Concrete Mathematics} style.

The \pkg{pseudo} box styles can be used used directly to style \code{tcolorbox}
environments, possiby with additional \pkg{tcolorbox} options for customization:
{
% \pseudoset{kw}
\label{ex:clrscode4ish}
\begin{texexp}
% In document preamble:
% \usepackage[cmyk]{xcolor}
% Partial clrscode4e.sty emulation:
\definecolor{lighttan}{cmyk}{0,0.05,0.17,0}
\pseudoset{label=\small\arabic*, hd-space}

\begin{tcolorbox}[pseudo/filled, colback=lighttan]
    \begin{pseudo}*
        \hd{Bor\r{u}vka}(V, E, w, T)            \\
        \kw{while} $E$ is not empty             \\+
            \kw{for} each $u\in V$              \\+
                add light $uv \in E$ to $T$     \\-
            \kw{for} each $e \in T$             \\+
                contract $e$
    \end{pseudo}
\end{tcolorbox}
\end{texexp}
}%
Beyond the boxes themselves, you can customize the pseudocode inside them
(separately from pseudocode elsewhere) by defining the \refk{in-float} style
with \refc{pseudodefinestyle}.

You can also create new environments with \cs{newtcolorbox},\footnote{See the
\pkg{tcolorbox} documentation for details and alternatives.} but the most common
use-case will probably be to define a (possibly floating) theorem-style
environment, using \cs{newtcbtheorem} (probably in the preamble):

\label{p:pseudo-ruled-def}
\begin{texexp}[listing]
\newtcbtheorem{algorithm}{Algorithm}{pseudo/ruled}{alg}
\end{texexp}

\noindent
Here \code{algorithm} is the name we've chosen for our new environment,
\code{Algorithm} is the label to be used when numbering (i.e., ``Algorithm~1'',
etc.), \refk{pseudo/ruled} is the ruled box style, and \code{alg} is is a prefix
that will be used in automatically labeling our boxes.

If you want a \emph{floating} box (like figures and tables, for example), simply
add the key \code{float} alongside the box style, such as:
\begin{texexp}[listing]
\newtcbtheorem{algorithm}{Algorithm}{pseudo/ruled, float}{alg}
\end{texexp}
%
Other \pkg{tcolorbox} styling options may be inserted in the same place. One can
also supply some \emph{init options} as a first argument, for configuring the
automatic numbering. For example, if we want our algorithms to be numbered
within sections, and we wish to provide \pkg{cleveref} with the appropriate
names, we could define the environment like this:\footnote{If you use the
\code{crefname} option, you should make sure to place your \cs{newtcbtheorem}
command in the preamble, and not in the document body, for the naming to take
effect.}
%
% Actual definition in preamble (so crefname works)
\begin{texexp}[listing]
\newtcbtheorem[
        number within = chapter,
        crefname = {Algorithm}{algorithms}
    ]%
    {algorithm}{Algorithm}{pseudo/ruled, float}{alg}
\end{texexp}
%
Once our environment has been defined with \cs{newtcbtheorem}, it can be used as
follows (here with floating turned off locally):

% Disappears when it's in a texexp, because the tcolorboxes check if they're
% first inside another box:
\vspace{0.5\baselineskip plus 2pt}
{
\pseudoset{kw}
\begin{texexp}
\begin{algorithm}{Sort an array $A$ of $n$ elements.}{gnome}
\begin{pseudo}
    $i = 1$                                     \\
    while $i < n$                               \\+
        if \nf $i\== 1$ or $A[i-1] \leq A[i]$   \\+
            $i = i + 1$                         \\-
        else \nf swap $A[i-1]$ and $A[i]$       \\+
            $i = i - 1$
\end{pseudo}
\end{algorithm}
\end{texexp}
}

The first argument is the title, or ``caption'', and the second argument
(\code{gnome}) is the \emph{marker}, which is combined with the prefix (in our
case, \code{alg}) to create the label, \code{alg:gnome}, which can be used with
\cs{ref} or (using \pkg{cleveref}) \cs{cref}, etc.:\footnote{The separator
(\code{:}) can be configured; see the \pkg{tcolorbox} docs.}

\begin{texexp}
\Cref{alg:gnome} is the well-known \emph{gnome sort}, by
Sarbazi-Azad and Grune.
\end{texexp}

% The internalpseudobox environment is defined in the preamble, so crefname
% works.
\noindent
\Cref{pbx:booktabs,pbx:boxed,pbx:boxruled,pbx:tworuled,pbx:filled} are typeset
with the remaining box styles.

\NewDocumentCommand \boxstylesample { m } {
\begin{internalpseudobox}[pseudo/#1]{\refk{pseudo/#1}}{#1}
\begin{pseudo}[kw]
    $i = 1$ \\
    while $i < n$\\+
        if \nf $i\== 1$ or $A[i-1] \leq A[i]$ \\+
            $i = i + 1$ \\-
        else \nf swap $A[i-1]$ and $A[i]$ \\+
            $i = i - 1$
\end{pseudo}
\end{internalpseudobox}
}

\boxstylesample{booktabs}
\boxstylesample{boxed}
\boxstylesample{boxruled}
\boxstylesample{tworuled}
\boxstylesample{filled}

Unnumbered boxes may be constructed with \cs{newtcolorbox}, using the same
styles. These boxes, by default, have no title part---only the main
body, containing the pseudocode itself:

{
\pseudoset{kw}
\begin{texexp}
\newtcolorbox{pseudobox}{pseudo/filled}

\begin{pseudobox}
\begin{pseudo}*
    \hd{Sum}(a, b)                              \\
    if $b \== 0$                                \\+
        return $a$                              \\-
    return $\pr{Sum}(a, b - 1) + 1$
\end{pseudo}
\end{pseudobox}
\end{texexp}
}

It is possible to add titles using the \code{title} key, but then the definition
must be expanded slightly, to permit arguments, e.g.:

\begin{texexp}[listing]
\newtcolorbox{pseudobox}[1][]{pseudo/filled, #1}
\end{texexp}
\newtcolorbox{pseudobox}[1][]{pseudo/filled, #1}% For later use
%
Here we've added a single argument (\code{[1]}), with an empty default
(\code{[]}), and this is spliced into the box options at the end. Now we
may con\-figure each box individually, as we please:

{
\pseudoset{kw}
\begin{texexp}
\begin{pseudobox}[title={\pr{Sum}(a, b)}]
\begin{pseudo}
    if $b \== 0$                                \\+
        return $a$                              \\-
    return $\pr{Sum}(a, b - 1) + 1$
\end{pseudo}
\end{pseudobox}
\end{texexp}
}%
%
Colors (e.g., \code{colback}, \code{colbacktitle} or \code{colframe}), fonts
(e.g., \code{fonttitle}), line thicknesses (\code{boxrule} or \code{titlerule}),
punctuation (\code{separator sign} and \code{terminator sign}) etc., may also be
configured, either for all the boxes of this type (directly in the call to
\cs{newtcolorbox}) or for any individual box, as with the \code{title} key in
the previous example. The style that is closest to a plain, default
\code{tcolorbox} is \refk{pseudo/boxruled}, which may be a good starting-point
for this kind of configuration. However, if you just wish to add some minor
tweaks to one of the existing \code{pseudo} styles (e.g., changing the colors of
\refk{pseudo/filled}), starting with that style may be easier. (For some hints
on configuring the boxes, see \cref{sec:boxconfig}.)

The contents of one of these boxes need not be restricted to pseudocode---the
spacing is set up to handle plain text as well. For example, you may want to
specify inputs and outputs.\footnote{Common alternatives to ``Input/Output'' are
``Require/Ensure'' and ``Data/Result''.} (If you want to align such
specification, as in \cref{alg:euclid} \vpageref{alg:euclid}, you can use the
\pkg{tabto} package; see \cref{sec:tabstops}.)

\vspace{0.5\baselineskip plus 2pt}
{
\pseudoset{kw}
\begin{texexp}
\begin{algorithm}{Gnome sort}{} % environment defined earlier

\textbf{Input:} An array $A$ of length $n$.

\textbf{Output:} $A$, sorted in nondescending order.

\begin{pseudo}
    $i = 1$                                     \\
    while $i < n$                               \\+
        if \nf $i \== 1$ or $A[i-1] \leq A[i]$  \\+
            $i = i + 1$                         \\-
        else \nf swap $A[i-1]$ and $A[i]$       \\+
            $i = i - 1$
\end{pseudo}

The running time of the algorithm is quadratic.

\end{algorithm}
\end{texexp}
}

\begin{sidebar}{Why only styles?}
Currently, \pkg{pseudo} defines only \pkg{tcolorbox} \emph{styles}, and not any
actual boxes or theorem-style environments. While this may change in the future,
it has a couple of advantages. First, the style definitions aren't dependent on
\pkg{tcolorbox} being imported, making it entirely optional. Second, when
defining the box or theorem environment, you can easily configure the counter
style, counter level, etc., through the normal \pkg{tcolorbox} mechanisms.
Similar customization mechanisms would have to be defined, anyway, and there is
no real point in aliasing them, rather than simply using the originals.
\end{sidebar}


\chapter{Reference}
\label{sec:reference}

This section gives an overview of all the moving parts of the package. A
\emph{default} value is one used implicitly if the key is specified with no
explicit value given, while an \emph{initial} value is one provided to the key
at the point where \pkg{pseudo} is imported. Several commands (such as, e.g.,
\refc{pseudoprefix}) may be modified using corresponding keys (e.g.,
\refk{prefix}). When the behavior of such commands is described, the description
references their initial behavior.

\section{Line structure}
\label{sec:linestructure}

Each line of a \refe{pseudo} environment is (initially) structured as follows:

\smallskip
\begin{center}
\begin{tikzpicture}
    \matrix (line) [
        matrix of nodes,
        % Hard-coding, or it would use semithick, rather than very thin:
        inner sep=-.1pt,
        row sep=-.2pt,
        column sep=-.2pt,
        nodes={
            inner xsep=.5em,
            inner ysep=2pt,
            rectangle,
            draw,
            very thin,
            minimum width=3em,
            minimum height=24pt,
            text depth=.5ex,
            text height=2ex,
            nodes in empty cells,
        },
        ]
    {

        \refk{bol}
        & step
        & \refk{label}
        & \verb|&|
        & |[auto]| save
        & |[auto]| ind.
        & |[auto]| \refk{font}
        & body
        & \refk{eol}
        & \verb|\\|
        \\
    };

    \draw[semithick, decorate, decoration={calligraphic brace,mirror}]
        ($(line-1-1.south west)+(1pt,-4pt)$)
        --
        node[inner sep=0, midway, below=5pt] (prefix) {\refk{prefix}}
        ($(line-1-4.south east)+(-1pt,-4pt)$)
        ;

    \draw[semithick, decorate, decoration={calligraphic brace,mirror}]
        ($(line-1-5.south west)+(1pt,-4pt)$)
        --
        node[inner sep=0, midway, below=5pt] (setup) {\refk{setup}}
        ($(line-1-7.south east)+(-1pt,-4pt)$)
        ;

    \draw[overlay] (prefix.south) node[font=\footnotesize, below=2pt, inner sep=0pt]
        {\strut Inserted by \refc{\bslash} (not \code{\refc{\bslash}*})};

    \draw (setup.south) node[font=\footnotesize, below=2pt, inner sep=0pt]
        {\strut Part of preamble};

    \draw[semithick] (line-1-9.south) + (0,-4pt)
    -- (line-1-9.south |- setup.south)
        node[font=\footnotesize, below=2pt, inner sep=0pt]
        {\strut Inserted by \refc{\bslash} (not last)};

    \draw[semithick] (line.south west) rectangle (line.north east);
\end{tikzpicture}
\end{center}
\vspace{-2.5pt}

\noindent
The components in the \refk{prefix} are populated by the \refc{\bslash}
command (or the beginning of the environment), the ones in the \refk{setup} by
the \refk{preamble}, and the actual body is supplied by the user, inside the
environment, terminated by the row separator \refc{\bslash} (which then goes
on to populate the next row, and so on). The \refk{eol} part is also inserted
by \refc{\bslash}, except if it's used after the last line (where it doesn't
really do anything).\footnote{Thus, \refk{eol} acts more as a line
\emph{separator} than a line \emph{terminator}.} The following describes the
default behavior, which can be modified substantially by setting the
appropriate options (e.g., \refk{prefix} and \refk{setup}).

\begin{description}[style=sameline, font=\normalfont]
    \item[\refk{bol}] This field is inserted by \refc{\bslash} (and
        \code{\cs{begin}\braces{\refe{pseudo}}}) at the beginning of the
        following line, using the \refc{pseudobol} command. Because it's a the
        very beginning of the tabular row, it may be used for things like
        \cs{rowcolor} when highlighting lines (as with the \refk{hl} key).
    \item[step] This refers to a call to \cs{stepcounter*} (where \refk{*} is
        an alias for \refk{pseudoline}), getting the counter ready for the
        label itself. Note that this does \emph{not} use \cs{refstepcounter},
        so at this point the counter has not been saved yet (and so you should
        not use \cs{label} to refer to it at this point).
    \item[\refk{label}]
        This is where the numbering label is inserted, using
        \refc{pseudolabel}; initially, this inserts
        \code{\cs{arabic}\refk{*}}.
    \item[\code{\&}] At the end of the prefix is the column separator, closing
        the label column and beginning the code line column.
    \item[save] Now that we're in the column where the user will normally
        insert text and code, we save \refk{pseudoline} so it may be used with
        \cs{label} and \cs{ref}, etc. This is done using
        \refc{pseudosavelabel}, which first \emph{decrements} the counter (to
        undo the increment before the label) and then calls
        \cs{refstepcounter}.
    \item[ind.] Inserts the appropriate amount of indentation (with an indent
        step length set by \refk{indent-length} or \refk{indent-text} and the
        indentation level set by \code{+}/\code{-} flags or
        \refk{indent-level}), using \refc{pseudoindent}.
    \item[\refk{font}] Inserts the base font, using \refc{pseudofont}.
    \item[body] This is where the manually written body of the code line
        appears.
    \item[\refk{eol}] Inserted by the terminating \refc{\bslash} (using
        \refc{pseudoeol}), unless we're at the end of the environment. Useful,
        e.g., for taking actions such as a
        \pkg{beamer} \cs{pause} (cf., \refk{pause}) between the
        lines.\footnote{If the same action must be taken after the last line,
        you can simply insert it there manually.}
    \item[\refc{\bslash}] The row/line separator. Ends one line (inserting
        \refk{eol}) and begins another (inserting \refk{prefix}). As in
        tabulars in general, this command is also permitted after the final
        line of the environment, but there it does no real work (i.e., it does
        not insert \refk{eol} and does not start a new line).
\end{description}

\section{Command and key reference}
\label{sec:cmdandkeyref}

In addition to descriptions of the various commands and options/keys (in
alphabetical order), you'll find definitions of a couple of counters here
(\refk{*} and \refk{pseudoline}).

% Not really a key, of course -- a counter
\begin{docKey}{*}{}{}
    This counter is a duplicate of \refk{pseudoline}, available inside
    \refe{pseudo}. It makes it possible to simplify calls such as
    \code{\cs{arabic}\braces{\refk{pseudoline}}} to starred forms such as
    \cs{arabic*}, like in \pkg{enumitem}. These short forms are available (and
    intended) for use in \refk{label} and \refk{ref}.
\end{docKey}

\begin{docCommand}{..}{}
    \parindent1.5em
    \noindent
    This is a shortcut that hijacks the normal \cs{.}\@ accent command, so
    that if it is called with \code{.}\@ as an argument, the result is
    \refc{dts} (or, rather, the fully prefixed \cs{pseudodts}). In other words,
    the command \cs{..}\@ is really the call \code{\cs{.}\braces{.}}. For any
    other arguments, the original \cs{.}\@ is used, so while
    \code{\$1\cs{..}n\$} produces $1\..n$, \code{\cs{.}o} still yields~\.o.

    Because \refc{..} isn't an ordinary macro, it cannot be overridden by a
    simple \cs{let} statement. Instead, the part that produces the actual output
    may be overridden by using the \refk{dts-impl} key. For example, if you'd
    like to use the \refc{..} shortcut, but prefer to use \cs{dots} or
    \refc{rng} as your range operator, you could achieve that as follows:

\begin{texexp}
\pseudoset{dts-impl=\dots}
$1\..n$

\pseudoset{dts-impl=\rng}
$1\..n$
\end{texexp}
\end{docCommand}

\begin{docCommand}{==}{}
    \parindent1.5em
    \noindent
    \RestorePseudoEq % Having some trouble bc/o floats, or something?
    This is a shortcut that hijacks the normal \cs{=} accent command, so that
    if it is called with \code{=} as an argument, the result is \refc{eqs} (or,
    rather, the fully prefixed \cs{pseudoeqs}). In other words, the command
    \cs{==} is really the call \code{\cs{=}\braces{=}}. For any other arguments,
    the original \cs{=} is used, so while \code{\$x\cs{==}y\$} produces $x\==y$,
    \code{\cs{=}o} still yields \=o.

    In some contexts, this may not work because \cs{=} has reverted to its
    original meaning (as is currently the case if you try to use it within a
    custom float, as in \cref{sec:floats}, or a standard one such as
    \code{figure}). In this case, you can restore the \pkg{pseudo} meaning (and
    the \refc{==} shortcut) by using \refc{RestorePseudoEq}. In some cases, you
    may want to just use \refc{eqs} instead.

    Because \refc{==} isn't an ordinary macro, it cannot be overridden by a
    simple \cs{let} statement. Instead, the part that produces the actual output
    may be overridden by using the \refk{eqs-impl} key. For example, if you'd
    like to use the \refc{==} shortcut, but prefer to use \cs{equiv} as your
    range operator, you could achieve that as follows:

\begin{texexp}
\pseudoset{eqs-impl=\equiv}
$1\==n$
\end{texexp}
\end{docCommand}

\begin{docCommand}{\protect\bslash}{\,\colOpt{+}%
    \,\colOpt{-}%
    \,\colOpt{*}\,%
    \colOpt{<\meta{overlay specification}>}\,\oarg{line options}}

    \parindent1.5em
    \noindent
    This row separator is the workhorse of the \pkg{pseudo} package. Just as in
    a \code{tabular} environment, it signals the end of a line. It is optional
    after the list line, where it doesn't do any work.
%
    The command may be followed by a series of one or more plus (\code{+})
    signs, each of which will increment the indentation level before starting
    a new line; similarly, it may be followed by one or more minus (\code{-})
    signs, each of which will decrement the indentation level.
%
    Normally, the command will insert a \refk{prefix} at the beginning of the
    new line; if the star (\code{*}) flag is used, this prefix is not
    inserted.

    The optional overlay specifications refer to the \refk{hl} key, so
    \code{\refc{\bslash}<3>} is equivalent to \code{\refc{\bslash}[hl<3>]}.
    This applies to the following line, as do other options set explicitly as
    optional arguments. Note that options are set locally, \emph{before} the
    new line (and a new scope) is started, so unless they are handled
    specifically (in order to carry over), they will have no effect. Thus,
    even though all options are available here, not all make sense. (Consult
    individual option keys for intended use.)

    The pluses and minuses are conceptually part of the command name, and
    there should be no whitespace before the
    star (\code{*}).
    %
    You are, however, free to insert whitespace before the overlay
    specification and the line options. This means that you may, for example,
    place the overlay specification at the beginning of the following line in
    the source.

    The \refc{\bslash} command is special in that it also permits a keyless
    value to be used among its option; this will then be taken to implicitly use
    the key \refk{extra-space}, which adds extra vertical space below as part of
    the line break. This means you can supply a length argument in the same way
    as with the ordinary \cs{\bslash} command:

\begin{texexp}
\begin{pseudo}
    no extra space after this line              \\
    but there's extra space after this line     \\[2ex]
    so this line is a bit lonely
\end{pseudo}
\end{texexp}
\end{docCommand}

\begin{docCommand}{arabic*}{}
    See \refk{*}.
\end{docCommand}

\begin{docKey}{begin-tabular}{\,=\,\meta{commands}}{no default}
    The actual command for beginning the \code{tabular} or \code{tabular}-like
    environment used by \refe{pseudo}. Normally not needed, as the
    \code{tabular} behavior may be modified by other keys, but could be used
    to use some other tabular environment, e.g., from packages such as
    \pkg{tabularx} or \pkg{longtable}. Rather than
    \code{\cs{begin}\braces{tabularx}} and \code{\cs{end}{\braces{tabularx}}},
    the command versions \cs{tabularx} and \cs{endtabularx} should be used.
    Commands such as \refc{pseudopos} and \refc{pseudopreamble} may be used as
    part of the setup:
\begin{texexp}[listing]
\pseudoset{
    begin-tabular =
        \tabularx{\linewidth}[\pseudopos]{\pseudopreamble},
    end-tabular = \endtabularx
}
\end{texexp}
\end{docKey}

\begin{docKey}{bol}{\,=\,\meta{commands}}{\initiallyempty}
    Used to set \refc{pseudobol}, which is inserted at the beginning of each
    line. See also \refk{bol-append} and \refk{bol-prepend}.
\end{docKey}

\begin{docKey}{bol-append}{\,=\,\meta{commands}}{no default}
    Locally appends \meta{commands} to \refk{bol}.
\end{docKey}

\begin{docKey}{bol-prepend}{\,=\,\meta{commands}}{no default}
    Similar to \refk{bol-append}, except that \meta{commands} are added to
    the \emph{beginning} of \refk{bol}.
\end{docKey}

\begin{docCommand}{cn}{\marg{name}}

    Indicates a constant (such as \cn{true} or \cn{nil}). First wraps the
    argument in \cs{textnormal} and then uses \refc{cnfont}. See also
    \refc{DeclarePseudoConstant}.
    \fontutil{constants}
    \pseudoshortcutted{cn}

\end{docCommand}

\begin{docKey}{cnfont}{\,=\,\meta{command}}{\initialkeyvalue{\cs{textsc}}}
    \fontkey{cn}
\end{docKey}
\begin{docCommand}{cnfont}{}
    \fontcmd{cn}
\end{docCommand}

\begin{docKey}{compact}{\,=\,\meta{boolean}}{default \code{true}, initially
    \code{false}}

    \parindent1.5em
    \noindent
    The \refe{pseudo} environment emulates the built-in \LaTeX\ lists when it
    comes to spacing above and below, in normal text. If the environment is
    part of an ongoing paragraph, paragraphs will be inserted above and below,
    along with whitespace specified by \refk{topsep} (and \cs{parskip}). If
    the environment begins a paragraph of its own, additional whitespace is
    added, as specified by \refk{partopsep}. It is also possible to specify
    space to insert to the left of the environment, using \refk{left-margin}.

    However, these spacing commands don't work well inside \cs{mbox},
    \cs{fbox}, etc. To avoid getting into trouble, \pkg{pseudo} determines that
    the environment should be \emph{compact}, and drop this surrounding space,
    if we're in inner horizontal mode at the beginning of the environment. This
    will also turn off setting \cs{prevdepth} (cf.\@ \refk{prevdepth}).

\begin{texexp}
% In document preamble:
% \usepackage{tikz}
\begin{tikzpicture}
    \draw (0,0) node [draw] {%
        \begin{pseudo}
            if we're in a node \\+
                there's no added space
        \end{pseudo}};
\end{tikzpicture}
\end{texexp}

    This may not be enough, however. For example, if you're using
    \pkg{standalone} to produce individual pseudocode images, this compactness
    may not be triggered automatically. In such cases, you can override the
    behavior using the \refk{compact} key, manually specifying whether you want
    the pseudocode to be compact or not.
\end{docKey}

\begin{docCommand}{ct}{\marg{text}}
    Indicates that \meta{text} is a comment, \ct{typeset like this}. You can
    customize the comment appearance using \refk{ctfont}, \refk{ct-left} and
    \refk{ct-right}:

\begin{texexp}
\pseudoset{
    ctfont=\color{black!75},
    ct-left=\unskip\qquad\texttt{/* },
    ct-right=\texttt{ */}
}
\begin{pseudo}
    $y=1$ \\
    $x=2$ \ct{this is a comment} \\
    $z=345$ \ct{this is another comment}
\end{pseudo}
\end{texexp}

    An alternative to using \refc{ct} is to simply set comments in a separate
    column, as demonstrated in \cref{sec:tabularx}. Or even without a separate
    column, if you use a \code{tabularx} as described there, and set the
    tabular width explicitly, you could insert an \cs{hfill} into
    \refk{ct-right} and get all end-markers aligned at the right-hand side:

    \medskip\noindent

    \begin{pseudo}[
        begin-tabular=\tabularx{\linewidth}[t]{@{}r>{\pseudosetup}X@{}},
        end-tabular=\endtabularx,
        ctfont=\color{black!75},
        ct-left=\unskip\qquad\texttt{/* },
        ct-right=\hfill\texttt{ */}
        ]
        $x=1$ \\
        $y=2$  \ct{this is a comment} \\
        $z=345$ \ct{this is another comment}
    \end{pseudo}

    \medskip\noindent

    Or if you'd rather have the comments right-aligned (like you can in, e.g.,
    \pkg{algorithm2e}), you could use insert the \cs{hfill} at the beginning of
    the \refk{ct-left}:

    \medskip\noindent

    \begin{pseudo}[
        begin-tabular=\tabularx{\linewidth}[t]{@{}r>{\pseudosetup}X@{}},
        end-tabular=\endtabularx,
        ctfont=\color{black!75},
        ct-left=\hfill\texttt{/* },
        ct-right=\texttt{ */}
        ]
        $x=1$ \\
        $y=2$  \ct{this is a comment} \\
        $z=345$ \ct{this is another comment}
    \end{pseudo}
\end{docCommand}

\begin{docKey}{ct-left}{\,=\,\meta{text}}{\initialkeyvalue{\code{(}}}
    \leftbracketing{comment}{ct}
\end{docKey}
\begin{docKey}{ct-right}{\,=\,\meta{text}}{\initialkeyvalue{\code{)}}}
    \rightbracketing{comment}{ct}
\end{docKey}
\begin{docKey}{ctfont}{}{\initialkeyvalue{\cs{textit}}}
    The font of the main text of a comment, when using \refc{ct}.
\end{docKey}
\begin{docCommand}{ctfont}{}
    \fontcmd{ct}
\end{docCommand}

\begin{docCommand}{DeclarePseudoComment}{\marg{shortcut}\marg{comment}}
    Used to declare a macro that expands to a comment. For example:
\begin{texexp}
\DeclarePseudoComment \Imp {Important!}
$x = y$ \qquad \Imp
\end{texexp}
    \seealsostyle{ct}
\end{docCommand}

\begin{docCommand}{DeclarePseudoConstant}{\marg{shortcut}\marg{constant}}
    Used to declare a macro that expands to a constant. For example:
\begin{texexp}
\DeclarePseudoConstant \False {false}
\False
\end{texexp}
    \seealsostyle{cn}
\end{docCommand}

\begin{docCommand}{DeclarePseudoFunction}{\marg{shortcut}\marg{function}}
    Used to declare a macro that expands to a function. For example:
\begin{texexp}
\DeclarePseudoFunction \Ln {length}
\Ln(A) or \Ln[A]
\end{texexp}
    \seealsostyle{fn}
\end{docCommand}

\begin{docCommand}{DeclarePseudoIdentifier}{\marg{shortcut}\marg{identifier}}
    Used to declare a macro that expands to a identifier. For example:
\begin{texexp}
\DeclarePseudoIdentifier \Rank {rank}
\Rank
\end{texexp}
    \seealsostyle{id}
\end{docCommand}

\begin{docCommand}{DeclarePseudoKeyword}{\marg{shortcut}\marg{keyword}}
    Used to declare a macro that expands to a keyword. For example:
\begin{texexp}
\DeclarePseudoKeyword \While {while}
\While
\end{texexp}
    \seealsostyle{kw}
\end{docCommand}

\begin{docCommand}{DeclarePseudoNormal}{\marg{shortcut}\marg{text}}
    Used to declare a macro that expands to normal text. For example:
\begin{texexp}
\DeclarePseudoNormal \Error {halt with an error message}
\begin{pseudo*}[kw]
    if $x \== \cn{nil}$ \\+
        \Error
\end{pseudo*}
\end{texexp}
    \seealsostyle{tn}
\end{docCommand}

\begin{docCommand}{DeclarePseudoProcedure}{\marg{shortcut}\marg{procedure}}
    Used to declare a macro that expands to a procedure. For example:
\begin{texexp}
\DeclarePseudoProcedure \Euclid {Euclid}
\Euclid(a, b)
\end{texexp}
    \seealsostyle{pr}
\end{docCommand}

\begin{docCommand}{DeclarePseudoString}{\marg{shortcut}\marg{string}}
    Used to declare a macro that expands to a string. For example:
\begin{texexp}
\DeclarePseudoString \Hello {Hello!}
\Hello
\end{texexp}
    \seealsostyle{st}
\end{docCommand}

\begin{docKey}{dim}{}{}
    Dims the following line. Equivalent to:
\begin{texexp}[listing]
\pseudodefinestyle{dim}{
    bol-append   = \color{\pseudodimcolor},
    setup-append = \color{\pseudodimcolor}
}
\end{texexp}
May be used to dim out inactive or currently less relevant lines (possibly
using overlays; see~\cpageref{p:overlays}).
\begin{texexp}
\begin{pseudo}[kw, dim-color=black!25]*
\hd{Gnome-Sort}(A)                              \\
[dim]  $i = 1$                                  \\
[dim]  while $i \leq \fn{length}[A]$            \\+
           if $i \== 1$ or $A[i] \geq A[i-1]$   \\+
               $i = i + 1$                      \\-
[dim]      else \nf swap $A[i]$ and $A[i-1]$    \\+
[dim]          $i = i - 1$
\end{pseudo}
\end{texexp}
See also \refk{bol-append}, \refk{setup-append} and \refk{dim-color}.
\end{docKey}

\begin{docKey}{dim-color}{\,=\,\meta{color}}{no default, initially
    \cs{pseudohlcolor}}
    Sets the color used by \refk{dim} (available as \cs{pseudodimcolor}). The
    initial value is the one set by \refk{hl-color}.
\end{docKey}

% Wirth notation, Pascal
% https://proofwiki.org/wiki/Definition:Real_Interval/Notation/Wirth
% https://en.wikipedia.org/wiki/Ellipsis_(computer_programming)
\begin{docCommand}{dts}{} % The name in Concrete Mathematics
    \parindent1.5em
    \noindent
    A two-dot ellipsis, for use in the Wirth interval notation $1\..n$,
    typeset as \citeauthor{Graham:1994} did in
    \citetitle{Graham:1994}~\citep{Graham:1994}. Its definition is the same as
    in \pkg{gkpmac}. Also accessible via the \refc{..}\@ shortcut (which calls
    the fully prefixed command \cs{pseudodts}). See also \refc{rng}.

    \pseudoshortcutted{dts}
\end{docCommand}
\begin{docKey}{dts-impl}{\,=\,\meta{code}}{\initialkeyvalue{\cs{pseudodts}}}
    The code used internally by the \cs{..} command, to produce the actual
    output. The initial value is the fully prefixed version of the \refc{dts}
    command.
\end{docKey}

\begin{docKey}{end-tabular}{}{\initialkeyvalue{\code{\cs{end}\braces{tabular}}}}
    The actual command for ending the \code{tabular} or \code{tabular}-like
    environment used by \refe{pseudo}. (See \refk{begin-tabular}.)
\end{docKey}

\begin{docKey}{eol}{\,=\,\meta{commands}}{\initiallyempty}
    Sets \refc{pseudoeol}, which is inserted at the end of all but the last
    line by \refc{\bslash}. See also \refk{eol-append} and \refk{eol-prepend}.
\end{docKey}

\begin{docKey}{eol-append}{\,=\,\meta{commands}}{no default}
    Locally appends \meta{commands} to \refk{eol}.
\end{docKey}

\begin{docKey}{eol-prepend}{\,=\,\meta{commands}}{no default}
    Similar to \refk{eol-append}, except that \meta{commands} are added to
    the \emph{beginning} of \refk{eol}.
\end{docKey}

\begin{docCommand}{eqs}{}
    \parindent1.5em
    \noindent
    Two equality signs typeset together as a binary relation, as in $x \eqs
    y$ (as opposed to the wider $x == y$, resulting from \code*{\$x == y\$}).
    It emulates the \pkg{stix} symbol \cs{eqeq}, but for use with Computer
    Modern (the default \LaTeX\ font) or Latin Modern (available via the
    \pkg[https://ctan.org/tex-archive/info/lmodern]{lmodern} package). It should
    work just fine with other fonts. Also accessible via the \refc{==} shortcut
    (which calls the fully prefixed command \cs{pseudoeqs}), and configurable
    via \refk{eqs-pad}, \refk{eqs-scale} and \refk{eqs-sep}.

    \pseudoshortcutted{eqs}
\end{docCommand}
\begin{docKey}{eqs-impl}{\,=\,\meta{code}}{\initialkeyvalue{\cs{pseudoeqs}}}
    The code used internally by the \cs{==} command, to produce the actual
    output. The initial value is the fully prefixed version of the \refc{eqs}
    command.
\end{docKey}
\begin{docKey}{eqs-pad}{\,=\,\meta{muskip}}{\initialkeyvalue{\code{0.28mu}}}
    The amount of space inserted on each side of \refc{eqs}.
\end{docKey}
\begin{docKey}{eqs-scale}{\,=\,\meta{number}}{\initialkeyvalue{\code{0.6785}}}
    The amount of horizontal scaling applied to the \code{=} signs in
    \refc{eqs}.
\end{docKey}
\begin{docKey}{eqs-sep}{\,=\,\meta{muskip}}{\initialkeyvalue{\code{0.63mu}}}
    The amount of space inserted between the two \code{=} signs in \cs{eqs}.
\end{docKey}

\begin{docKey}{in-float}{}{\pkg{pseudo} style}
    This is a style, defined using \refc{pseudodefinestyle}, that is applied to
    the contents of every \code{tcolorbox} styled using the \code{pseudo/}
    styles, such as \refk{pseudo/boxed}, \refk{pseudo/ruled}, etc. (Despite the
    name, it is not limited to boxes defined with the \code{float} key.) The
    style is initially empty, and acts as a hook for user customization (similar
    to \refk{pseudo/init}, but specifically for \pkg{pseudo} configuration):
    \begin{texexp}
    \pseudodefinestyle{in-float}{kwfont = \sffamily}
    \kw{not modified}
    \begin{tcolorbox}[pseudo/filled]
        \kw{modified}
    \end{tcolorbox}
    \end{texexp}
\end{docKey}

\begin{docKey}{extra-space}{\,=\,\meta{length}}{\initialkeyvalue{\code{0pt}}}
    \parindent1.5em
    \noindent
    Additional space to be added by \refc{\bslash}, below the baseline of the
    current row. For example:

\begin{texexp}
\begin{pseudo}[indent-mark, extra-space=2ex]
    a                                           \\+
        b                                       \\+
            c
\end{pseudo}
\end{texexp}
Note the difference from \refk{line-height}: Here the space is added below, just
like with the \emph{normal} \cs{\bslash} command, when its optional argument is
used, whereas with \refk{line-height} the height and depth of the line are both
scaled. Also, unlike with \refk{line-height}, with \refk{extra-space}, nothing
is added to the last line unless it actually ends with a \refc{\bslash} command.

The most likely use-case for this command is to add space after specific lines,
rather than for \emph{every} line, as in the previous example. For example:
\begin{texexp}
\begin{pseudo}
    one group that is           \\
    logically connected         \\ [extra-space=1.5ex]
    another group that is       \\
    separate from the first
\end{pseudo}
\end{texexp}
In fact, \refk{extra-space} is so closely tied to \refc{\bslash}, that you can
supply a keyless value as one of its options, and \refk{extra-space} will be
\emph{assumed}. So, for example, in the previous example, you could simply have
used \code{\cs{\bslash}[1.5ex]}.

If you want spacing only after the heading (created with \refc{hd}), you can set
that using the \refk{hd-space} key.
\end{docKey}

\begin{docCommand}{fn}{\marg{name}\colOpt{(\meta{arguments})}}

    Indicates a function name, such as \fn{length}, and is initially
    more or less an alias for \refc{id}. The optional arguments (given in
    parentheses) are typeset in math mode, so
    \code{\cs{fn}\braces{length}(A)} yields \fn{length}(A).
    %
    Sometimes square brackets are used with functions that are meant to
    indicate array lookups or some property access or the like. This works in
    the same manner, so
    \code{\cs{fn}\braces{length}[A]} yields \fn{length}[A]. This behavior of
    picking up arguments carries over if you define a shortcut, of course:
\begin{texexp}
\def\Ln{\fn{length}}
We're not in math mode, but the argument of \Ln[A] is.
\end{texexp}

    % Should typeset \fn{test}[A] followed by (B) in normalfont:
    % \fn{test}[A](B)
    % Should typeset \fn{test}(A) followed by [B] in normalfont:
    % \fn{test}(A)[B]
    See also \refc{DeclarePseudoFunction}.
    \fontutil{function names}
    \pseudoshortcutted{fn}
\end{docCommand}

\begin{docKey}{fnfont}{\,=\,\meta{font}}{\initialkeyvalue{\refc{idfont}}}
    \fontkey{fn}
\end{docKey}
\begin{docCommand}{fnfont}{}
    \fontcmd{fn}
\end{docCommand}

\begin{docKey}{font}{\,=\,\meta{command}}%
    {\initialkeyvalue{\cs{normalfont}}}
    Sets the base font used in the code lines. Initially, this is just
    \cs{normalfont}, but the \refk{kw} switch is a convenient way to set it to
    the keyword font \refc{kwfont}. This is presumed to be a common case,
    under the assumption that most of the pseudocode will consist of either
    keywords or mathematics. If you'd rather explicitly mark up your keywords,
    leaving \refk{font} as it is, you could use \refc{kw} (or
    \refc{DeclarePseudoKeyword} for common cases):
\begin{texexp}
\begin{pseudo*}
\kw{while} pigs don't fly                       \\+
    keep waiting
\end{pseudo*}
\end{texexp}
\end{docKey}

\begin{docCommand}{hd}{\marg{name}(\meta{arguments})}
    \parindent1.5em
    \noindent
    Typesets a procedure signature, like \refc{pr}, but is intended for use as
    a \emph{header} for a procedure, rather than a procedure call. The
    difference is that \cs{hd} wraps its contents in a \cs{multicolumn},
    spanning two columns (i.e., both the label column and the main code
    column, but not any additional columns added using \refk{preamble} or
    \refk{begin-tabular}), using the preamble set with \refk{hd-preamble}. For
    this to work, you need to use the star flag (\code{*}) to suppress the
    automatic insertion of the \refk{prefix}:

\begin{texexp}
\begin{pseudo}*
    \hd{Algorithm}(x, y, z)                     \\
    setup                                       \\
    \kw{while} condition                        \\+
        iterative step                          \\-
    \kw{return} result
\end{pseudo}
\end{texexp}

    \noindent
    The \refk{hd-space} key can be used to configure \refc{hd} so it sets the
    \refk{extra-space} key. Note that the signature arguments are mandatory; in
    order to function properly, \cs{hd} must be \emph{expandable}, and therefore
    cannot end with an optional argument, the way \refc{pr} does. Also, it is
    not able to determine nesting levels of parentheses, so the arguments are
    terminated upon encountering the first closing parentheses. If you want to
    use parentheses in the arguments themselves, you must wrap them in braces,
    or thing will get wonky:

\begin{texexp}
\begin{pseudo}*
\hd{Foo}(G=(V, E), w, s)                        \\*
\hd{Foo}({G=(V, E), w, s})                      \\
lorem ipsum dolor sit amet, consetetur
\end{pseudo}
\end{texexp}

    \noindent
    \pseudoshortcutted{hd}
\end{docCommand}

\begin{docKey}{hd-preamble}{\,=\,\meta{columns}}{no default}
    Sets the preamble used by \refc{hd}. The result is available as the column
    type with name \cs{pseudohdpreamble}. (Note that this is the literal
    column name, and not a macro containing the name. See \refk{preamble} for
    more information.) Initially, a single left-aligned column with
    \refc{pseudohpad} on either side (see \cpageref{p:hdpreamble}). If you
    introduce more columns in \refk{preamble}, you might want to increase the
    number of columns in \refk{hd-preamble} as well, or at least remove the
    right-hand \refc{pseudohpad}.
\end{docKey}

\begin{docKey}{hd-space}{\,=\,\meta{length}}{default \code{0.41386ex}, initial
    value \code{0pt}}
    The value \refk{extra-space} is set to (before any value set manually as
    part of \refc{\bslash}) after the use of \refc{hd}. This is useful if one
    wants some extra space only after the header. The default is based on
    \pkg[https://www.cs.dartmouth.edu/~thc/]{clrscode4e},\footnote{And older
    versions, for that matter.} and, so getting spacing header spacing similar
    to that package requires only \code{\cs{pseudoset}\braces{hd-space}}. (See,
    e.g., the example \vpageref{ex:clrscode4ish}.)
\end{docKey}

\begin{docKey}{hl}{}{\novaluekey}
    Prepends \refc{pseudohl} to \refk{bol}. Normally used with \pkg{beamer} (see
    \cpageref{p:overlays}). Note that if if \refk{hpad} is set, a warning will
    be emitted (unless this is overridden by \refk{hl-warn}).
\end{docKey}

\begin{docKey}{hl-color}{\,=\,\meta{color}}{\initialkeyvalue{\code{black!12}}}
    Sets the color used by \refc{pseudohl} (available as \cs{pseudohlcolor}).
\end{docKey}

\begin{docKey}{hl-warn}{\,=\,\meta{warn}}{default \code{true}, initial
    value \code{true}}
    Permits turns off (by setting \refk{hl-warn} to \code{false}) the warning
    that is normally emitted if you use \refk{hl} without having used
    \refk{hpad}.
\end{docKey}

\begin{docKey}{hpad}{\,=\,\meta{length}}%
    {default \code{0.3em}, initially \code{0em}}
    Horizontal padding on either side of the pseudocode. Useful, among other
    things when highlighting lines, to have some of the highlighting (i.e.,
    row color) protrude beyond the text. This key also sets \refk{hl-warn} to
    \code{false}.
\end{docKey}

\begin{docKey}{hsep}{\,=\,\meta{length}}%
    {\initialkeyvalue{\code{0.75em}}}
    The space between the line labels and the code lines, i.e., between the
    two columns of numbered \refEnv*{pseudo} environments.
\end{docKey}

\begin{docCommand}{id}{\marg{name}}
    Indicates an identifier, and is simply an alias for \cs{textit} wrapped in
    \cs{textnormal}.
    See also \refc{DeclarePseudoIdentifier}.
    \fontutil{identifiers}
    \pseudoshortcutted{id}

    \medskip

    It might seem more natural to use \cs{mathit} (without \refCom*{tn}), but
    that may not give the desired results. First of all, special characters
    will not behave as if they're parts of a name:

\begin{texexp}
$\mathit{foo-bar:baz}$
\end{texexp}

    This may be remedied, e.g., by using the (internal) command
    \cs{newmcodes@} from \pkg{amsopn}, but the kerning, spacing and font
    application in the result still leaves something to be desired:

\makeatletter
\begin{texexp}
$\mathit{\newmcodes@ foo-bar:baz}$
\end{texexp}
\makeatother

    Compare this to a simple \cs{textit}:

\begin{texexp}
$\textit{foo-bar:baz}$
\end{texexp}

    The decision to use \cs{textit} means that you can't use, say, subscripts
    or the like as parts of an identifier, or mix in greek letters or other
    mathematical symbols. Though you can still easily typeset things like
    $\id{foo-$\alpha$}$, you'll have to mix in the math mode more
    explicitly (in this case, \verb|$\id{foo-$\alpha$}$|).
%
    \pseudoshortcutted{id}
\end{docCommand}
\begin{docKey}{idfont}{\,=\,\meta{font}}{\initialkeyvalue{\cs{textit}}}
    \fontkey{id}
\end{docKey}
\begin{docCommand}{idfont}{}{}
    \fontcmd{id}
\end{docCommand}

\begin{docKey}{indent-length}{\,=\,\meta{length}}{\initiallyempty}
    How large each indentation step is. If this key is not specified,
    \refk{indent-text} is used to calculate one the indent length instead.
\end{docKey}

\begin{docKey}{indent-level}{\,=\,\meta{level}}{no default, initially \code{0}}
    Sets the current indentation level. This is most usefully set on
    \refe{pseudo} environment, in concert with \refk{start}:\footnote{The
    \cs{strut} here is just to even out spacing above and below the text,
    which doesn't have fixed-height lines like the pseudocode.}
\begin{texexp}
\begin{pseudo}
    this is                                     \\+
    the first part
\end{pseudo}

\medskip \strut
This is some text interrupting the code.
\medskip

\begin{pseudo}[start=3, indent-level=1]
    this is the                                 \\-
    second part
\end{pseudo}
\end{texexp}
\end{docKey}

\def\algoexample#1{%
\begin{pseudo}[#1]
\kw{repeat} $n-1$ times \\+
    \kw{for} each edge $uv$ \\+
        update estimate for $v$ via $u$ \\--
\kw{for} each edge $uv$ \\+
    \kw{if} estimate for $v$ improves via $u$ \\+
        \kw{return} \cn{false} \\--
\kw{return} \cn{true}
\end{pseudo}
}
\begin{docKey}{indent-mark}{\,=\,\meta{mark}}{default vertical line, initially
    empty}
A mark used to indicate the start of each step of indentation.\footnote{Similar
to \code{c:indentLine\_char} in the vim plugin
\pkg[https://github.com/Yggdroot/indentLine]{indentLine}.}
Any horizontal space taken up by this mark is added to the indentation; to
prevent this, wrap the mark in \cs{rlap} (and, if necessary, in \cs{smash}, to
handle \emph{vertical} space). The following example uses
\verb|indent-mark=\rlap{$\cdot$}|:

\algoexample{indent-mark=\rlap{$\cdot$}}
%
By default, the indent mark is a vertical line that scales with the line height,
so each indented block is indicated by a single unbroken vertical line. It also
``undoes'' its own width, so it doesn't impact the indentation. The following
example uses the \refk{indent-mark} key with no argument:

\algoexample{indent-mark}
%
This default mark may be configured by using the keys \refk{indent-mark-color},
\refk{indent-mark-width} and \refk{indent-mark-shift}.
\end{docKey}

\begin{docKey}{indent-mark-color}{\,=\,\meta{color}}%
    {\initialkeyvalue{\codefont{lightgray}}}
    Sets the color to be used by the default \refk{indent-mark}. See
    \refk{indent-mark-shift} for an example.
\end{docKey}

\begin{docKey}{indent-mark-shift}{\,=\,\meta{length}}{default \code{.6em},
        initial value \code{0pt}}
    Sets the horizontal shift (from the actual start of an indent step) at which
    to render the default \refk{indent-mark}. The following example uses the
    default value, and sets \refk{indent-mark-width} to \code{.4pt} and
    \refk{indent-mark-color} to \code{black}, to approximate the look of the
    indent mark in \pkg{algorithm2e}.
\algoexample{indent-mark, indent-mark-shift, indent-mark-color=black,
indent-mark-width=.4pt}
\end{docKey}

\begin{docKey}{indent-mark-width}{\,=\,\meta{width}}%
    {\initialkeyvalue{\codefont{.6pt}}}
    Sets the width of the default \refk{indent-mark}. See
    \refk{indent-mark-shift} for an example.
    %
    The default value of \code{.6pt} corresponds to the
    \pkg[https://ctan.org/pkg/pgf]{tikz} line width \code{semithick}.
\end{docKey}

\begin{docKey}{indent-text}{\,=\,\meta{text}}%
    {\initialkeyvalue{%
    \code*{\cs{pseudofont}\cs{kw}\braces{else}\cs{\verbvisiblespace}}}}
    The size of each indentation step is set to the width of the \meta{text}.
    The default is set up so that code following on the same line as \kw{else}
    will be properly aligned, as in:

    \medskip

    \begin{pseudo*}[kw]
        if \tn{condition} \\+
            \tn{something} \\-
        else \tn{something else}
    \end{pseudo*}

    \medskip

    If you're not going to put code on the same line as \kw{else}, for
    example, you might want a different indentation size. To set it to some
    specific length, you could use
    the \refKey*{indent-length} key.
\end{docKey}

\begin{docKey}{init}{\,=\,\meta{commands}}{\initiallyempty}
    Used to set the initialization hook, which is inserted at the beginning of
    the \refe{pseudo} environment (right before the actual tabular environment
    begins, as defined by \refk{begin-tabular}). See also \refk{init-append} and
    \refk{init-prepend}.
\end{docKey}

\begin{docKey}{init-append}{\,=\,\meta{commands}}{no default}
    Locally appends \meta{commands} to \refk{init}.
\end{docKey}

\begin{docKey}{init-prepend}{\,=\,\meta{commands}}{no default}
    Similar to \refk{init-append}, except that \meta{commands} are added to
    the \emph{beginning} of \refk{init}.
\end{docKey}

\begin{docKey}{kw}{}{\novaluekey}
    Sets \refk{font} to \refc{kwfont}.
\end{docKey}
\begin{docCommand}{kw}{\marg{name}}
    Indicates a keyword. First wraps the argument in \cs{textnormal} and then
    adds \cs{kwfont}.
    See also \refc{DeclarePseudoKeyword}.
    \fontutil{keywords}
    \pseudoshortcutted{kw}
\end{docCommand}

\begin{docKey}{kwfont}{\,=\,\meta{font}}{%
    \initialkeyvalue{\code{\cs{fontseries}\braces{b}\cs{selectfont}}}}
    \fontkey{kw}
    Note, however, that with the \refk{kw} switch, you set \code*{\refk{font}
    = \refc{kwfont}}, which is then applied as a font-switching command for
    each entire line, taking no argument. If you provide an command requiring
    an argument, the \refc{kw} command will still work, but the \refk{kw}
    switch won't:
\begin{texexp}
\pseudoset{kw}
\begin{pseudo*}[kwfont=\textsf]    % breaks kw option
    foo \kw{bar}
\end{pseudo*}
vs.\
\begin{pseudo*}[kwfont=\sffamily]  % works with kw option
    foo \kw{bar}
\end{pseudo*}
\end{texexp}
    The initial value isn't \emph{quite} as straightforward as indicated,
    however.
    For more info, see \refc{kwfont}.
\end{docKey}

\begin{docCommand}{kwfont}{}
    \parindent1.5em
    \noindent
    \fontcmd{kw}
    Its initial definition is \emph{essentially}
    \code{\cs{fontseries}\braces{b}\cs{selectfont}}, except the first time
    it's called (normally when evaluating the initial value of
    \refk{indent-text}), it also runs a check to see if the font selection
    \emph{worked}, as in some cases (such as in a default
    \pkg{beamer} presentation), the non-extended bold may not be available. In
    that case, it defaults to an extended bold (\cs{bfseries}) instead. At this
    point, the command is redefined to
    \code{\cs{fontseries}\braces{b}\cs{selectfont}} or \cs{bfseries}, as
    appropriate (i.e., without this check). So, while
    \code{\refc{kw}\braces{hello}} produces the non-extended \kw{hello} in a
    default \LaTeX\ document, it yields the extended {\origbfseries\sffamily
    hello} in a default \pkg{beamer} presentation. Perhaps more clearly, this is
    the result in plain \LaTeX\ (using
    \pkg[https://ctan.org/tex-archive/info/lmodern]{lmodern}):

{\let\bfseries\origbfseries
\begin{texexp}
\textbf{while}\\                  % Extended
\kw{while}\\                      % Keyword
{\fontseries{b}\selectfont while} % Non-extended
\end{texexp}
}\ignorespaces\par

    \noindent
    The same code results in the the following in \pkg{beamer}:

    \medskip\noindent
    \includegraphics{kwfig.pdf}

    \medskip\noindent
    You'll also get a font warning,\footnote{Of course, if you use a different
    font or theme, e.g., with the \pkg{beamer} command
    \code{\cs{usefonttheme}\braces{serif}}, you may not have any issues to begin
    with.} though only once, as it's suppressed after the first occurrence, so the
    fact that the font selection doesn't work on the last line isn't reported.

    \begin{note}
    The current implementation of \refc{kwfont} actually \emph{piggybacks} on
    this warning to determine if the non-extended bold is available. This means
    that if you've tried (and failed) to use \code{\cs{fontseries}\braces{b}}
    \emph{before} the fist use of \refc{kwfont}, the fallback (i.e., extended
    bold) won't be triggered.
    \end{note}

    Note that \refk{indent-text} (which will tend to be the first occurrence use
    of \refc{kwfont}) won't be evaluated (to determine \refk{indent-length})
    until you actually start a \refe{pseudo} environment, so if you're
    \emph{aware} that you don't have non-extended bold available, and you set
    \code*{\refk{kwfont} = \cs{bfseries}}, for example, there will be no attempt
    to use the non-extended version, and you won't get the font warning that the
    default implementation produces in that case.
\end{docCommand}

\begin{docKey}{label}{\,=\,\meta{commands}}{%
    \initialkeyvalue{\code{\refc{arabic*}}}}%
    \parindent1.5em
    \noindent
    Used to format the line label/number. For example, to emulate
    \pkg[https://www.cs.dartmouth.edu/~thc/]{clrscode4e} rather than
    \pkg{clrscode3e}, you'd use \code*{label = \cs{small}\cs{arabic}*}. You can
    also add punctuation or the like, as in \pkg{enumitem}:
\begin{texexp}
\pseudoset{kw, label=\footnotesize\arabic*:}

\begin{pseudo}
print \st{Hello, label!} \label{li:label}       \\
goto \tn{\ref{li:label}}
\end{pseudo}
\end{texexp}

    \begin{note}
    Make sure to use \cs{label} in the actual code line, as here, and not in the
    number cell (which is generally not explicitly written, anyway).
    \end{note}

    As can be seen from the example, \cs{ref} is unaffected by
    \refKey*{label}, and in many cases that's what you want---as apposed to,
    say, ``\kw{goto} {\footnotesize 1:}''. In some cases, however (especially
    when using one of the other formatting commands, such as \cs{alph} or
    \cs{roman}), you \emph{do} want the reference format to reflect the
    original, or be similar in some way. To do that, you use the
    \refKey*{ref} key.
\end{docKey}

\begin{docKey}{label-align}{\,=\,\meta{column}}{\initialkeyvalue{\code{r}}}%
    Used to specify the alignment of the \refk{label} of each line. Whatever
    is provided is stored as a column type (named \cs{pseudolabelalign}),
    which is a part of the default \refk{preamble}. In other words, beyond the
    basic \code{l} and \code{r} (for left- and right-justified), you can
    supply anything that would be valid as part of the preamble (possibly
    using functionality from the \pkg{array} package). If you want to get
    creative here, though, it might be easier to get the results you want by
    specifying your own \refk{preamble} in full.
\end{docKey}

\begin{docKey}{left-margin}{\,=\,\meta{length}}{\initialkeyvalue{\code{0pt}}}
    Sets the left margin of the \code{pseudo} environment, i.e., how far it is
    indented wrt.\ the surrounding text:
\begin{texexp}
Lorem ipsum dolor sit amet:

\begin{pseudo}[left-margin=1.25em]
consetetur sadipscing elitr \\
sed diam nonumy eirmod tempor
\end{pseudo}

Invidunt ut labore et dolore magna.
\end{texexp}

To have the environment indented as (the beginning of) any normal paragraph,
you could use \code*{left-margin = \cs{parindent}}. Note that
\refk{left-margin}, as well as the spacing above and below the \refe{pseudo}
environment, is turned off inside \cs{mbox} and the like:
\begin{texexp}
\pseudoset{left-margin=1cm} % Won't affect box contents
\fbox{\begin{pseudo*}
I'm a livin' in a box \\
I'm a livin' in a cardboard box
\end{pseudo*}}
\end{texexp}
As opposed to with \refk{topsep} and \refk{partopsep}, we are \emph{not} working
with one of the built-in list spacing commands; \cs{leftmargin} has no effect on
this key (which is why the hyphenated naming style of other keys such as
\refk{label-align} or \refk{indent-text} is also adopted for
\refk{left-margin}).
%
See also \refk{compact}.
\end{docKey}

\begin{docKey}{line-height}{\,=\,\meta{factor}}{\initialkeyvalue{\code{1}}}
    The \meta{factor} with which to multiply the ordinary line height. For
    simple, sparse pseudocode, the oridnary line height works well, but if
    your code
    gets too crowded with text and notation, you may wish to increase
    \code{line-height}. To emulate, e.g., the
    \cs{jot} set by
    \pkg{amsmath} (which is \code{0.25\cs{baselineskip}}), you could use
    \code{1.25}, though even \code{1.1} should help in many cases.
\end{docKey}

\begin{docCommand}{nf}{}
    Switch to the normal font (i.e., without bold or italics, etc.).
    \shortcutted{nf}{normalfont}
    See also \refc{tn}.
\end{docCommand}

\begin{docKey}{partopsep}{\,=\,\meta{length}}{\initialkeyvalue{\cs{partopsep}}}
    Sets a \pkg{pseudo}-local copy of \cs{partopsep} for use in vertical spacing
    above and below the \refe{pseudo} environment. See also \refk{compact}.
\end{docKey}

\begin{docKey}{pause}{}{\novaluekey}
    Equivalent to \code*{\refk{eol-append} = \cs{pause}} (see \cref{p:pause}).
\end{docKey}

\begin{docKey}{pos}{\,=\,\meta{depth}}{\initialkeyvalue{\code{t}}}
    Specifies the vertical position of the \refe{pseudo} environment, i.e.,
    whether it should be vertically aligned on the top (\code{t}) or bottom
    (\code{b}) row, or be vertically centered (no value).
%
    This is equivalent to the (optional) \code{pos} argument to \code{tabular},
    and is in fact supplied to the internal \code{tabular} environment. The
    initial value is \code{t}, which makes sure the spacing above is
    consistent, regardless of the depth of the previous line. Here are two
    examples, set side by side:

    \medskip

    \begin{minipage}[t]{1.1cm}
    $x$
    \begin{pseudo}
    foo \\
    bar
    \end{pseudo}
    \end{minipage}
    \begin{minipage}[t]{1.1cm}
    $f(x)$
    \begin{pseudo}
    frozz \\
    bozz
    \end{pseudo}
    \end{minipage}

    \medskip

    The \refe{pseudo} environments are properly aligned. If, instead, we set
    \code*{pos = \braces{}}, they will not be, because $f(x)$ has more depth
    than $x$:\footnote{This was the behavior in older versions of
    \pkg{pseudo}.}

    \medskip

    \begin{minipage}[t]{1.1cm}
    $x$
    \begin{pseudo}[pos=]
    foo \\
    bar
    \end{pseudo}
    \end{minipage}
    \begin{minipage}[t]{1.1cm}
    $f(x)$
    \begin{pseudo}[pos=]
    frozz \\
    bozz
    \end{pseudo}
    \end{minipage}

    \medskip

    If \refk{compact} is set to \code{true}, \refk{pos} is automatically
    emptied like this---a behavior which can, of course, be overridden:

    \begin{texexp}
    Lorem
    \begin{pseudo*}[compact]
        foo \\ bar
    \end{pseudo*}
    ipsum
    \begin{pseudo*}[compact, pos=b]
        foo \\ bar
    \end{pseudo*}
    dolor
    \begin{pseudo*}[compact, pos=t]
        foo \\ bar
    \end{pseudo*}.
    \end{texexp}
\end{docKey}

\begin{docCommand}{pr}{\marg{name}\colOpt{(\meta{arguments})}}
    Indicates a procedure name, such as \cn{Quicksort}, and is initially
    more or less an alias for \refCom*{cn}. The optional arguments (in
    parentheses) are typeset in math mode, so
    \code{\cs{pr}\braces{Quicksort}(A,p,r)} yields \pr{Quicksort}(A,p,r).
    See also \refc{DeclarePseudoProcedure}.
    \fontutil{procedure names}
    \pseudoshortcutted{pr}
\end{docCommand}

\begin{docKey}{preamble}{\,=\,\meta{columns}}{no default}
    Sets the preamble to be used by the internal \code{tabular}. The result is
    available as the column type with name \cs{pseudopreamble}. (Note that
    this is the literal column name, and not a macro containing the name.
    Initially, \pkg{pseudo} uses a \code{tabular} as redefined by the
    \pkg{array}, which prevents the expansion of whatever is provided as its
    preamble, and so we supply the preamble in the form of a single ``column''
    instead.) For the default value, see the actual implementation on
    \cpageref{p:preamble} as well as the explanation in
    \cref{sec:linestructure}.
\end{docKey}

\begin{docKey}{prefix}{\,=\,\meta{commands}}{no default}
    This is the text inserted at the beginning of the following line by
    \refc{\bslash} (and by \code{\cs{begin}\braces{\refe{pseudo}}}), unless
    you use the star (\code{*}) flag. Unless modified, it inserts the code
    necessary to label the line and to move into the second column, where the
    actual code is inserted by the user. For the default value, see the actual
    implementation on \cpageref{p:prefix} as well as the explanation in
    \cref{sec:linestructure}.
\end{docKey}

\begin{docKey}{prevdepth}{\,=\,\meta{depth}}{\initialkeyvalue{\code{.3\cs{baselineskip}}}}
    This value is used to properly adjust the vertical distance to any
    following text, by setting \cs{prevdepth} to \meta{depth}, unless
    \refk{compact} is set to \code{true}. In general, it should not be
    necessary to change its value.\footnote{In previous versions,
    \cs{prevdepth} was not set. To get the old behavior, set \code*{prevdepth =
    0pt}.}
\end{docKey}

\begin{docKey}{prfont}{\,=\,\meta{font}}{\initialkeyvalue{\refc{cnfont}}}
    \fontkey{pr}
\end{docKey}
\begin{docCommand}{prfont}{}
    \fontcmd{pr}
\end{docCommand}

\begin{docEnvironment}[doclang/environment content=pseudocode]%
    {pseudo}{\oarg{options}\,\colOpt{*}\,\colOpt{<\meta{overlay
    specification}>}\,\oarg{line options}}
    The actual environment in which the pseudocode is typeset. The
    \meta{options} are local to the environment, while the \meta{line options}
    are local to the following line (in the same manner as those set in
    \refc{\bslash}; i.e., only some will actually have any effect). The star
    (\code{*}) and \meta{overlay specification} act just like those on
    \refc{\bslash}. Note that if you wish to specify \meta{line options}
    without the star or the \meta{overlay specification}, you need to supply
    at least an empty pair of brackets for the global options:
\begin{texexp}
\pseudoset{hpad} % because we're using hl
\begin{pseudo}[][hl]
First line \\
Second line
\end{pseudo}
vs.\
\begin{pseudo}[hl]
First line \\
Second line
\end{pseudo}
\end{texexp}
    There are no \code{+}/\code{-} flags here, unlike for \refc{\bslash};
    if needed, you can use \refk{indent-level}.
\end{docEnvironment}

\begin{docEnvironment}[doclang/environment content=pseudocode]%
    {pseudo*}{\oarg{options}\,\colOpt{*}\,\colOpt{<\meta{overlay
    specification}>}\,\oarg{line options}}
    An unnumbered version of the \refe{pseudo} environment. Equivalent to
    \refe{pseudo}, but with the \code{starred} style applied
    (see~\cpageref{p:starred}). Unless this style is altered, this means that
    the label column is removed from the preamble, and the prefix is reduced
    to only \refk{bol}.
\end{docEnvironment}

\begin{docKey}{pseudo/boxed}{}{\pkg{tcolorbox} style}
    \tcolorboxstylepre

\begin{texexp}
\begin{tcolorbox}[pseudo/boxed,
    title={Algorithm 1\enskip \pr{Hello}(x)}]
    \begin{pseudo}
        \kw{print} \st{Hello,} $x$
    \end{pseudo}
\end{tcolorbox}
\end{texexp}

    \tcolorboxstylepost
\end{docKey}
%
\tcolorboxstylenosource{booktabs}
\tcolorboxstylenosource{boxruled}
\tcolorboxstylenosource{filled}

\begin{docKey}{pseudo/init}{\,=\,\meta{commands}}{\pkg{tcolorbox} hook}
    Can be used to define the contents of a hook that is inserted before the
    contents of a \pkg{tcolorbox} box styled with one of the \code{pseudo/}
    styles, such as \refk{pseudo/boxruled}, etc. It is used as part of the
    \pkg{tcolorbox} configuration, and is \emph{not} set using \cs{pseudoset}.
    Useful, e.g., for setting \cs{parskip} or tabstops (with the \pkg{tabto}
    package).
\begin{texexp}
\begin{tcolorbox}[pseudo/boxed, pseudo/init=\parskip 2ex]
Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed
diam nonumy eirmod tempor invidunt ut labore et dolore magna.

At vero eos et accusam et justo duo dolores et ea rebum. Stet
clita kasd gubergren, no sea takimata sanctus est Lorem ipsum
dolor sit amet.
\end{tcolorbox}
\end{texexp}
\end{docKey}

\tcolorboxstylenosource{ruled}
\tcolorboxstylenosource{tworuled}

\begin{docCommand}{pseudobol}{}
    \setandused{bol}{pseudoprefix}
\end{docCommand}

\begin{docCommand}{pseudodefinestyle}{\marg{name}\marg{options}}
    Used to define ``styles'' or meta-keys, i.e., shortcuts for setting
    several keys to given values (used, e.g., to define \refk{starred}). The
    \meta{name} is simply the name of the new meta-key, and the \meta{options}
    are just what you'd provide to, e.g., \refc{pseudoset}.
\end{docCommand}

\begin{docCommand}{pseudoeol}{}
    \setandused{eol}{\bslash}
    It is inserted between lines, but not after the last one.
\end{docCommand}

\begin{docCommand}{pseudofont}{}
    \setandused{font}{pseudosetup}
    It is used to set up the font for each pseudocode line. (See also
    \refk{kw}.)
\end{docCommand}

\begin{docCommand}{pseudohl}{}
    This is the command inserted as \refk{bol} by the \refk{hl} switch.
    Initially, it's just a \cs{rowcolor} using the color set by
    \refk{hl-color}, but you could redefine it to whatever you wish.
\end{docCommand}

\begin{docCommand}{pseudohpad}{}
    Used on the left- and right-hand sides of \refk{preamble}.
    Conceptually, it inserts the horizontal space specified by \refk{hpad}. To
    play nice with \cs{rowcolor}, however, it is not used in a
    \code{@\braces{\dots}} column; rather, it's placed in
    \code{>\braces{\dots}} and \code{<\braces{\dots}} modifiers, and the
    actual space inserted has \cs{tabcolsep} subtracted.
\end{docCommand}

\begin{docCommand}{pseudoindent}{}
    % Protrudes into the margin:
    % \setandused{indent-length}{pseudosetup}
    % Manual:
    The command set by the \refk{indent-length} and \refk{indent-mark} options.
    Used in \refc{pseudosetup}.
    More precisely, \refk{indent-length} is stored textually, and is converted
    to the length \cs{pseudoindentlength} when entering a \refe{pseudo}
    environment (so that units like \code{em} and \code{ex} adapt to the
    current font). If no \refk{indent-mark} is set, the \cs{pseudoindent}
    command then inserts a horizontal space of length
    $\cs{pseudoindentlength}\times\mkern-1.8mu\textit{current indent level}$.
    Otherwise, one \refk{indent-mark} and a horizontal space of length
    \cs{pseudoindentlength} is inserted for each level of indentation up to the
    current indentation level. (This horizontal space is measured from the left
    edge of the \refk{indent-mark}.)
\end{docCommand}

\begin{docCommand}{pseudolabel}{}
    \setandused{label}{pseudoprefix}
\end{docCommand}

% Counter, not key
\begin{docKey}{pseudoline}{}{}
    Counter for pseudocode lines. See also \refk{*}.
\end{docKey}

\begin{docCommand}{pseudopos}{}
    \setandusedinit{pos}{begin-tabular}
\end{docCommand}

\begin{docCommand}{pseudopreamble}{}
    \setandusedinit{preamble}{begin-tabular}
\end{docCommand}

\begin{docCommand}{pseudoprefix}{}
    \setandused{prefix}{\bslash}
\end{docCommand}

\begin{docCommand}{pseudosavelabel}{}
    Used as part of \refc{pseudosetup} to save the \refk{pseudoline} counter
    for use in \cs{label} and \cs{ref}. The \refk{pseudoline} counter is
    \emph{incremented} as part of the \refc{pseudolabel} command, but that's
    done using a plain \cs{stepcounter}, as any use of \cs{label} will
    presumably be placed in the pseudocode line (i.e., the next column). To
    save the value there, \cs{pseudosavelabel} first \emph{decrements} the
    counter, and then uses \cs{refstepcounter}.
\end{docCommand}

\begin{docCommand}{pseudoset}{\marg{options}}
    Used to set the configuration keys of the \pkg{pseudo} package (using
    \pkg{l3keys} with \code{pseudo} as the module). These may also be set as
    % package options (in \cs{usepackage}) and as
    optional arguments to the \refEnv*{pseudo} and \refEnv*{pseudo*}
    environments. For example, if you'd like to switch to \cs{rm} as your base
    font, you could use \code*{\cs{pseudoset}\braces{font = \cs{rm}}}.
\end{docCommand}

\begin{docCommand}{pseudosetup}{}
    The command set by the \refk{setup} option. Used as part of the
    \refk{preamble}.

    \medskip

    \emph{Not to be confused with \refc{pseudoset}.}
\end{docCommand}

\begin{docKey}{ref}{\,=\,\meta{commands}}{initially empty, default
    \refc{pseudolabel}}
    Shortcut for setting the \cs{thepseudoline} command. If used without
    arguments, it will use the value supplied to \refKey*{label}.
\begin{texexp}
\pseudoset {
    label = (\textsc{\alph*}),
    ref   = \Alph*,
    hsep  = .5em
}

\begin{pseudo}
print \st{Hello, ref!} \label{li:ref} \\
goto \tn{\ref{li:ref}}
\end{pseudo}
\end{texexp}
\end{docKey}

\begin{docCommand}{RestorePseudoBackslash}{}
    Command similar to the \cs{arraybackslash} of the \pkg{array} package.
    Switches the definition of \cs{\bslash} to the one used by \pkg{pseudo}.
    Useful if you've used some code that modifies \cs{\bslash} for its own
    purposes (such as \cs{raggedleft} or the like).
\end{docCommand}

\begin{docCommand}{RestorePseudoEq}{}
    Similar to \refc{RestorePseudoBackslash}. Switches the definition of \cs{=}
    to the one used by \pkg{pseudo}. Useful if \cs{=} reverts to its original
    definition in some context (see \refc{==}).
\end{docCommand}

\begin{docCommand}{rng}{}
    Used to typeset a range, slice or subarray, or simply to indicate the
    indices of an array, similar to \refc{dts}, but using a colon rather than
    two dots placed horizontally. Uses the same spacing as \refc{dts}, as
    opposed to a plain \code{:}, which adds more space (more suitable, for
    example, to set-builder notation).
\begin{texexp}
Compare $A[1\rng n]$ to $A[1:n]$.
\end{texexp}
    \pseudoshortcutted{rng}
\end{docCommand}

\begin{docKey}{setup}{\,=\,\meta{commands}}{no default}
    The setup part of each pseudocode line: Save the line counter
    (using the \refc{pseudosavelabel} command), insert the proper indentation
    (with \refc{pseudoindent}) and switch to the correct font
    (\refc{pseudofont}).

    \medskip

    Rather than setting \refk{setup} directly, you may wish to add commands
    using \refk{setup-append} or \refk{setup-prepend}.
\end{docKey}

\begin{docKey}{setup-append}{\,=\,\meta{commands}}{no default}
    Locally appends \meta{commands} to \refk{setup}.
\end{docKey}

\begin{docKey}{setup-prepend}{\,=\,\meta{commands}}{no default}
    Similar to \refk{setup-append}, except that \meta{commands} are added to
    the \emph{beginning} of \refk{setup}.
\end{docKey}

\begin{docCommand}{st}{\marg{string}}
    Typesets \meta{string} with added quotes using \refc{stfont}. (The entire
    thing is wrapped in \cs{textnormal}.) For example, \code*{print
    \cs{st}\braces{42}} yields:
    \begin{pseudo*}
        print \st{42}
    \end{pseudo*}
    See also \refc{DeclarePseudoString}.
    \fontutil{strings}
    \pseudoshortcutted{st}
\end{docCommand}

\begin{docKey}{st-left}{\,=\,\meta{text}}{no default, initially \code{``}}
    \leftbracketing{string}{st}
\end{docKey}

\begin{docKey}{st-right}{\,=\,\meta{text}}{no default, initially \code{''}}
    \rightbracketing{string}{st}
\end{docKey}


\begin{docKey}{starred}{}{\novaluekey}
    The style (defined by \refc{pseudodefinestyle}) used by the \refe{pseudo*}
    environment. You may modify this (again using \refc{pseudodefinestyle}) if
    you wish.
\end{docKey}

\begin{docKey}{start}{\,=\,\meta{number}}{no default, initially \code{1}}
    Sets the starting line number:
\begin{texexp}
\begin{pseudo}[start=10]
Maybe we're continuing from some earlier code?  \\
Anyway, let's keep going!
\end{pseudo}
\end{texexp}
See also \refk{indent-level}.
\end{docKey}

\begin{docKey}{stfont}{}{}
    \fontkey{st}
\end{docKey}

\begin{docCommand}{stfont}{}
    \fontcmd{st}
\end{docCommand}

\begin{docCommand}{tn}{\marg{text}}
    An alias for \cs{textnormal}, to break out of the font set using the
    \refKey*{font} key, for inserting ordinary prose between the keywords. For
    example, to get the result ``{\kwfont for \tn{every node} $v\in V$}'', one
    might write:

    \medskip

    \centerline{\code{for \cs{tn}\braces{every node} \$v\cs{in} V\$}}

    \medskip

    This is equivalent to using \code*{\cs{textnormal}\braces{every node}}.
    \shortcutted{tn}{textnormal}
\end{docCommand}

\begin{docKey}{topsep}{\,=\,\meta{length}}{\initialkeyvalue{\cs{topsep}}}
    Sets a \pkg{pseudo}-local copy of \cs{topsep} for use in vertical spacing
    above and below the \refe{pseudo} environment. See also \refk{compact}.
\end{docKey}

\begin{docKey}{unknown}{}{}
    \parindent1.5em
    \noindent
    Unknown keys are checked for \pkg{beamer} overlay specifications. That is,
    if an unknown key has the form

    \medskip

    \centerline{\code*{\meta{name}<\meta{overlay
    specification}> = \meta{value}}}

    \medskip

    \noindent
    then it does not trigger an error, but, if \pkg{beamer} is used, is
    rewritten to:

    \medskip

    \centerline{\code*{\cs{only}<\meta{overlay specification}>\braces{%
        \refc{pseudoset}\braces{\meta{name} = \meta{value}}%
    }}}

    \medskip

    \noindent
    If \pkg{beamer} is \emph{not} used, the key is simply ignored.

    \begin{note}
    Currently, using commas in the \meta{overlay specification} doesn't
    work. As a workaround, you can use the key multiple times. That is, rather
    than \code{\refk{dim}<1,3>}, use \code{\refk{dim}<1>, \refk{dim}<3>}.
    \end{note}

    If an unknown key does \emph{not} take the form of a key with an overlay
    specification, a second special case is also handled: If we're processing
    arguments for \refc{\bslash}, and the key does not have an associated
    (non-blank) value, we treat the key instead as a \emph{value}, whose
    implicit key is \refk{extra-space}. This means that you can specify extra
    space in the ordinary way, with \code{\cs{\bslash}[1.5ex]}, etc.
\end{docKey}
\begin{sidebar}{Unknown Keys and Defaults}
Because of current limitations on how keys are handled,
% \footnote{\url{https://github.com/latex3/latex3/issues/67}.}
unknown keys cannot have defaults, and so there is no way to insert a
marker for when no value is provided, which could be used to determine
whether to use
\code*{\refc{pseudoset}\braces{\meta{name} = \meta{value}}}
or simply
\code*{\refc{pseudoset}\braces{\meta{name}}}. Instead, if an empty value
is provided to the unknown key, that is treated in the same way as when
the key is used
without a value, resulting in
\code*{\refc{pseudoset}\braces{\meta{name}}}
rather than
\code*{\refc{pseudoset}\braces{\meta{name} = }}.
\end{sidebar}

\chapter{But how do I\,\dots}

Some functionality is not built in, but is still fairly easy to achieve. Some
streamlining may be added in future versions.

\section{\dots\,prevent paragraph indentation after \code{pseudo}?}

If you want to keep the pseudocode as part of a surrounding paragraph, you
could have it not start its own, i.e., not have an empty line before it. This
will reduce the amount of spacing as well; if you'd rather have that reduced,
you could simply drop the empty line \emph{after} the environment:

\begin{texexp}[listing]
Text before

\begin{pseudo}
    pseudocode
\end{pseudo}
%
Text after
\end{texexp}

\noindent
The effect would then be the following:

\begin{pseudo}
    pseudocode
\end{pseudo}
%
No indentation here, and normal spacing. If, however, you wish to suppress
indentation after \emph{all} instances of \refe{pseudo}, you could use the
\pkg{noindentafter} package, as follows:

\medskip

\begin{texexp}[listing]
\usepackage{noindentafter}
\NoIndentAfterEnv{pseudo}
\NoIndentAfterEnv{pseudo*}
\end{texexp}

\noindent
If you wish to override this, and indent a given paragraph after all, you can
simply use the \cs{indent} command.

\section{\dots\,get log-like functions?}

There's no built-in command for math-roman function names, as used in $\log$
and $\sin$, etc. (other than just setting \refk{fnfont}, if you want it
everywhere). If you wish to define your own, you could use \cs{operatorname}
or \cs{DeclareMathOperator}. For example:

\begin{texexp}
% In document preamble:
% \usepackage{amsmath}
% \DeclareMathOperator{\MyFunc}{my-func}
\begin{pseudo}[kw]
if $\MyFunc x \== 1$ \\+
    $y = \MyFunc(z + 1)$
\end{pseudo}
\end{texexp}

\noindent
The spacing is then correct whether you enclose the arguments in parentheses
or not.

\section{\dots\,unbold punctuation?}

If you use the \refk{kw} key, all pseudocode not in math mode will end up
using the keyword font (\refc{kwfont}), which initially is bold. Though some
\emph{do} typeset, e.g., grouping braces in boldface, you might not want to do
that; the same goes for, say, line-terminating semicolons. The
\code{theoremfont} option of, e.g., \pkg{newtx} does something similar (for
italics), but uses a custom font for that. Packages like \pkg{emrac} rely on
straightforward textual substitution, replacing certain characters with
marked-up ones, but the way things are set up at the moment, our font command
won't have access to the entire line when it's executed.

If you're adventurous, it's not hard (using the \pkg{xparse} argument type
\code{u}) to make a version that \emph{does} gobble up the entire line, up to
and including \verb|\\| (and you could then use the regular expression
functionality from \pkg{expl3}, presumably also reinserting \refc{\bslash}). A
simpler solution is to just use \refc{DeclarePseudoNormal}. Here's an example
based on pseudocode from \citet{Knuth:1975}:

\begin{texexp}
% In document preamble:
% \usepackage{mathtools}
\let\gets\coloneqq

\pseudoset{kw, indent-length=2em, line-height=1.1}

\DeclarePseudoNormal \; ;

\begin{pseudo*}
procedure \id{printstatistics}\;                            \\
begin integer $j$\;                                         \\+
    \fn{write}(\st{Closed sets for rank}, r, \st{:})\;      \\
    $j \gets L[h]$\;                                        \\
    while $j \neq h$ do                                     \\+
        begin \fn{writeon}(S[j])\; $j\gets L[j]$ end\;      \\--
end\;
\end{pseudo*}
\end{texexp}

\noindent
If you'd really like to avoid the extra backslashes, you could make the
relevant punctuation active (though that's probably a bit risky; make sure to
only do it locally, at the very least):

\begin{texexp}
\DeclarePseudoNormal \semi ;

\catcode`\;=\active
\let;\semi

\begin{pseudo*}[kw]
    begin integer $j$; % Look! The semicolon isn't bold!
\end{pseudo*}
\end{texexp}

\section{\dots\,use \codefont{tabularx}?}
\label{sec:tabularx}

You can use other tabular packages such as \pkg{tabularx} via
\refk{begin-tabular} and \refk{end-tabular}. Let's say, for example, that you
wish to extend the \refe{pseudo} environment to fill out the entire line, and
set up a new column for comments. You could achieve that as
follows:\footnote{For an explanation of the use of \code{[t]}, see the
documentation of the \refk{pos} option.}

\label{p:fullwidth}
\begin{texexp}
\pseudodefinestyle{fullwidth}{
    begin-tabular =
    \tabularx{\linewidth}[t]{@{}
        r                                      % Labels
        >{\pseudosetup}                        % Indent, font, ...
        X                                      % Code (flexible)
        >{\leavevmode\small\color{gray}}       % Comment styling
        p{0.5\linewidth}                       % Comments (fixed)
        @{}},
    end-tabular = \endtabularx,
    setup-append = \RestorePseudoEq
}
\begin{pseudo}[kw, fullwidth, line-height=1.1]*
    \hd{Counting-Sort}(A, k) & Find positions by counting \\
    $C = \tn{an array of $k$ zeros}$ & Element frequencies \\
    for $i = 1$ to $A.\id{length}$ & Count all elements \\+
    $\dots$ & Etc.
\end{pseudo}
\end{texexp}
%
Note that using the \cs{color} command in a \code{>\braces{\dots}}
modifier with a \code{p} column places the text in a new paragraph, on the
next line; you'll need to insert \cs{leavevmode} or the like to prevent that.
This is true also of normal \code{tabular} environments. Also note
that \code{tabularx} environments with \code{X} columns don't interact nicely
with \cs{=}; so if you wish to use \refc{==}, you can reassert the definition
by adding \code{>\braces{\refc{RestorePseudoEq}}} before each
column.\footnote{You can also, of course, just use \refc{eqs} instead.}

See the \pkg{tabularx} documentation (page~4) for an explanation of why we can't
use \code{\cs{begin}\braces{tabularx}} and \code{\cs{end}\braces{tabularx}}.
Also, because \pkg{tabularx} passes its contents as the argument to a macro, the
parsing \pkg{pseudo} uses to determine if \refc{\bslash} is at the end of the
last line doesn't work; if you add \refc{\bslash} at the end here, you'll
introduce an empty line.

\makeatletter
For simplicity, I've used \code{@\braces{}} to remove space on either side.
For \refk{hpad} to work, you should use \code{>\braces{\cs{pseudohpad}}} and
\code{<\braces{\cs{pseudohpad}}} instead, as in the standard \refk{preamble}
(see \cpageref{p:preamble}). To keep things configurable, you might also want
to use \cs{pseudolabelalign}, rather than \code{r}.
\makeatother


\section{\dots\,get tab stops?}
\label{sec:tabstops}

Some packages, such as \pkg{clrscode3e}, use an actual \code{tabbing}
environment internally. While this may be a bit brittle (e.g., creating problems
if you wish to insert your pseudocode into a
\pkg[https://ctan.org/pkg/pgf]{tikz} node---one of the goals of \pkg{pseudo}),
it does mean that you can use the tabbing command \cs{>} manually, to align
various construct.

If all your tabbing is done \emph{before} the text on a given code line, you
can achieve this in \pkg{pseudo} as well, by using the \code{+} and \code{-}
modifiers. (For example, the tab stops in \pkg{clrscode3e} are set at fixed
intervals, just like in \pkg{pseudo}.) But what if you'd like to align something
that comes later, such as comments after code lines? You can't simply use
\cs{hspace}, of course, unless the code lines themselves have exactly the same
length.

One solution is to use an additional column, as discussed in
\cref{sec:tabularx}, but you could also make creative use of the \cs{rlap}
command, which prevents its contents from taking up horizontal space:%
\footnote{Note that \cs{rlap} doesn't start a new paragraph, which is why I
use \cs{noindent}, here. You could replace
\code{\cs{noindent}\cs{rlap}\braces{\dots}} with
\code{\cs{makebox}[0pt][l]\braces{\dots}}. This isn't an issue in
\code{pseudo} code lines, however.}

\begin{texexp}
\noindent\rlap{This is some text}%
And here is some more
\end{texexp}

\noindent
By using \cs{rlap} on the code lines in question, you can insert \cs{hspace}
that begins at the beginning of the code line (here with an example
convenience command defined using \pkg{xparse}):

\begin{texexp}
\NewDocumentCommand \C { +u{/* } +u{ */} } {%
    \rlap{#1}\hspace{3cm}\ct{#2}\\%
}
\begin{pseudo}
\C $x = 42$      /* first comment */
\C $y = \sin x$  /* second comment */
\end{pseudo}
\end{texexp}

\noindent
See also the discussion of the \refc{ct} command for ideas on typesetting
comments. If you wish to align things across different indentation levels,
you'll have to add or subtract multiples of \cs{pseudoindentlength} (see
\refc{pseudoindent}).

Another option for aligning comments or the like is to use a custom \cs{tabular}
or \cs{tabular}-like environment, where the aligned material is placed in a
column of its own. This is the technique used in \cref{alg:gnome}, for example.
For more on this approach, see \cref{sec:tabularx}.

If you want alignment or tabbing \emph{outside} the \refe{pseudo} environment,
for example, to align the input and output descriptions inside a
\code{tcolorbox} (cf.\@ \cref{sec:floats}), an excellent alternative is the
\pkg{tabto} package.
%
You could also use other constructs, such as a \code{tabular}, \code{tabbing} or
\code{description}. An advantage of the \pkg{tabto} solution is that you retain
the paragraph spacing set up by the \pkg{tcolorbox} styles defined by
\pkg{pseudo}.

You can simply define the tab stops globally, using \cs{TabPositions} in your
preamble, or you can do it as part of the box setup, e.g.,. using
\refk{pseudo/init} when defining your \pkg{tcolorbox} environment with
\cs{newtcbtheorem} (or, as in the following simplified example,
just supply it directly as an option to the box environment).

If you'd rather not separate the elements of, say, your input description by
paragraphs, you could of course use line breaks (\cs{\bslash}); however,
\cs{tab} won't work on its own at the beginning of the next line. To fix this,
simply add \cs{null} before it (i.e., use \cs{null}\cs{tab}).

\begin{texexp}
% In document preamble:
% \usepackage{tabto}
\begin{tcolorbox}[pseudo/filled,
    pseudo/init = {\TabPositions{1.5cm}}]

\textbf{Data}
    \tab A graph $G=(V,E)$ with weight function $w:E\to\mathbf{R}$

    \tab A start node $s\in V$

\textbf{Require}
    \tab No negative cycle in $G$ is reachable from $s$

\textbf{Result}
    \tab An array $d$ of distances from $s$

\begin{pseudo}
\dots
\end{pseudo}
\end{tcolorbox}
\end{texexp}


\section{\dots\,use horizontal lines?}
\label{sec:horizontallines}

Many opt for a table-like appearance when typesetting algorithms, with
horizontal lines above and below, and generally a header row on top. While
this may be part of a surrounding floating environment (see
\cref{sec:floats}), you may also wish to include such lines in your actual
pseudocode. In this case, you can simply use existing \code{tabular}-based
tools such as \pkg{booktabs}, making sure to suppress the \pkg{pseudo}
\refk{prefix} using the star flag (\code{*}):

\begin{texexp}
% In document preamble:
% \usepackage{booktabs}
\begin{pseudo}*
\toprule

    \hd{Bor\r{u}vka}(G, w)                      \\
                                                %
[bol=\midrule]

    \kw{while} $E(G)$ is not empty              \\+
        \kw{for} each $u\in V(G)$               \\+
            add light $uv \in E(G)$ to $T$      \\-
        \kw{for} each $e \in T$                 \\+
            contract $e$                        \\*

\bottomrule
\end{pseudo}
\end{texexp}

\noindent
Rather than \code{\cs{\bslash}[bol=\cs{midrule}]}, you could also have used
\code{\cs{\bslash}*}, followed by \code{\cs{midrule}\cs{pseudoprefix}}. (Note
that the paragraph break between \refc{\bslash} and its argument has been
commented out.)

\section{\dots\,handle object attributes?}

In the \pkg{clrscode3e} package, you'll find an assortment of commands for
handling object attributes such as $A.\id{length}$. The manual says (here with
emulated kerning of the dot operator):

\begin{quote}
    You might think you could typeset $A\mkern1mu.\id{length}$ by
    \code{\$A.\cs{id}\braces{length}\$}, but that would produce
    $A\mkern1mu.\mkern-1.5mu\id{length}$, which has not quite enough space
    after the dot. \hfill(page~3)
\end{quote}

\noindent
However, this is a font issue, more than anything. If, for example, if you
want Times New Roman (like Cormen et al.)\@ and use \pkg{mathptm}, you at times
run into the problem described; with \pkg{newtx} it's less pronounced. With
other fonts (e.g., \pkg{fourier}, \pkg{mathpple}, or \pkg{newtxmath} with
\pkg{libertine}), or even without any font packages (or possibly using
\pkg{lmodern}), the kerning works just fine.

In general, then, I suggest you try to use \code{\$A.\cs{id}\braces{length}\$}
and the like, and see if the result is satisfactory:

\begin{texexp}
$v.\id{prev}.\id{next} = v.\id{next}$
\end{texexp}

\noindent
If you \emph{do} need to adjust the kerning (with \cs{mkern} commands or
perhaps using \pkg{microtype}), you may of course do so, but \pkg{pseudo} does
not (at present) include any special attribute lookup commands that do it for
you.

\section{\dots\,indicate blocks with braces or the like?}

Some packages (such as \pkg{algorithm2e}) have support for using vertical lines
to indicate the block structure;
\pkg[https://ctan.org/tex-archive/macros/latex/contrib/pseudocode]{pseudocode}
uses large braces. In \pkg{pseudo}, there is support for using an
\refk{indent-mark}, for which the default is a semithick, gray vertical line
(see \cpageref{p:indent-mark}). However, by using
\pkg[https://ctan.org/pkg/pgf]{tikz}, you could draw all kinds of indentation
decorations.

You could, for example, add a \code{node} at the start of each code line,
containing an \verb|\@arstrut|, the (\pkg{array}) strut used to indicate the
extent of a tabular row:

% ! Contents duplicated
\makeatletter
\NewDocumentCommand \pseudoanchor { m } {%
    \tikz[baseline, overlay, remember picture]
        \node[anchor=base, inner sep=0] (#1) {\@arstrut};%
    \ignorespaces
}
\makeatother
\begin{texexp}[listing]
% \usepackage{xparse,tikz}
% \usetikzlibrary{decorations.pathreplacing,calligraphy}
\makeatletter
\NewDocumentCommand \pseudoanchor { m } {%
    \tikz[baseline, overlay, remember picture]
        \node[anchor=base, inner sep=0] (#1) {\@arstrut};%
    \ignorespaces
}
\makeatother
\end{texexp}

\noindent
You can then use the resulting nodes to draw braces or lines or whatever. First
some example setup:

% ! Duplicated
\begin{texexp}[listing]
\pseudoset{
    kw,
    indent-length = 3.5em,
    setup-append = {\pseudoanchor{L-\arabic*}}
}
\tikzset{
    braces/.style =
    {thick, decoration = {calligraphic brace, raise=.2em}},
    label/.style =
    {midway, left=3em, anchor=west, font=\strut\kwfont}
}
\end{texexp}
You would then get something like the following:
{
\pseudoset{
    kw,
    indent-length = 3.5em,
    setup-append = {\pseudoanchor{L-\arabic*}}
}
\tikzset{
    braces/.style =
    {thick, decoration = {calligraphic brace, raise=.2em}},
    label/.style =
    {midway, left=3em, anchor=west, font=\strut\kwfont}
}
\begin{texexp}
\begin{pseudo}
if $x < y$                                      \\+
    $x = y$                                     \\
    $y = 0$
\end{pseudo}
\tikz[overlay, remember picture, braces] {
    \draw[decorate] (L-3.south) -- (L-2.north) node[label] {then};
}
\end{texexp}
}

\noindent
If multiple blocks are closed at the same time, the bottom coordinates could be
things like \code*{(L-2.north |- L-3.south)} instead. To adjust the end
points, you could also use things like \code{(\$(L-3.south)+(0,.2em)\$)}.

The actual drawing of the brace (or line or whatever) isn't automated here, of
course. This could be done by some hook triggered by the \code{-} flags in
\refc{\bslash}. If it turns out there's a demand for something like that, I
might add it in a future version.

\section{\dots\,use \pkg{pseudo} with older \TeX\ distributions?}
\label{sec:older}

As mentioned in the introduction, I've tried to make \pkg{pseudo} work with at
least \emph{somewhat} outdated \TeX\ distributions. In these cases, the package
itself won't be available as part of the distribution, of course, but you can
simply download the file
\codefont{\href{http://mirrors.ctan.org/macros/latex/contrib/pseudo/pseudo.sty}%
{pseudo.sty}} and place it in the directory where you're compiling your document
(or anywhere else where your \LaTeX\ executable can find it).

However, there may be cases where this just doesn't work, such as when
submitting to a publisher with a really old setup.\footnote{If possible,
though, feel free to
\href{https://github.com/mlhetland/pseudo.sty/issues}{file an issue} or
\href{https://github.com/mlhetland/pseudo.sty/pulls}{provide a pull request}
to address the issue.}
In that case, the simplest solution is probably to use the
\pkg{standalone} package to produce individual PDFs of your algorithms, and then
to include those in your document. Then you can submit the PDFs rather than the
\LaTeX, so that the pseudocode need not be compiled on the old system. Each
algorithm could go in a file like this:

\begin{texexp}[listing]
\documentclass{standalone}
\usepackage{pseudo}
\begin{document}
\begin{pseudo}
    ...
\end{pseudo}
\end{document}
\end{texexp}

\noindent
Let's say this is compiled to \codefont{algo1.pdf}. You then include this file:

\begin{texexp}[listing]
\documentclass{article}
\usepackage{graphicx} % For \includegraphics
...
\begin{document}
... sanctus est Lorem ipsum dolor sit amet:

\medskip\noindent
\includegraphics{algo1.pdf}

\smallskip
Lorem ipsum dolor sit amet, consetetur sadipscing ...
\end{document}
\end{texexp}

\noindent
Of course, you can adjust the spacing (e.g., using \verb|\vspace| or the like)
to your liking. Using this method, you can can achieve results essentially
identical to if you compiled the pseudocode directly as part of the document.
Of course, you won't have access to other functionality (such as
\verb|\DeclarePseudoIdentifier| or the like) for use in the main tex, but most
of that should be possible to emulate by hand (possibly peeking at the
implementation in \cref{sec:impl}).

\section{\dots\,use a header with no arguments?}

Normally, \refc{hd} has a mandatory set of arguments; at the very least,
you'll need to supply the parentheses:

\begin{texexp}
\begin{pseudo}*
\hd{No-Arguments}() \\
\dots\ but still with parentheses
\end{pseudo}
\end{texexp}

\noindent
This is because \refc{hd} has to be fully expandable to be able to insert the
requisite \cs{multicolumn}, and then it cannot have any (final) optional
arguments. If you'd like, though, you can just use \cs{multicolumn} yourself
(see also \refk{hd-preamble}):

\begin{texexp}
\begin{pseudo}*
\multicolumn{2}{\pseudohdpreamble}
{\pr{No-Arguments}} \\
\dots\ and no parentheses!
\end{pseudo}
\end{texexp}

\section{\dots\,place algorithm boxes side by side?}

In the simplest case, maybe you just want to place two of them side by side in
the text (i.e., not as floats). Let's say you've defined an environment as
follows:

% Duplicated:
\newtcbtheorem{procedure}{Procedure}{pseudo/filled}{}
\begin{texexp}[listing]
\newtcbtheorem{procedure}{Procedure}{pseudo/filled}{}
\end{texexp}

Two of these cannot directly be placed side by side, because each will insert
paragraph breaks and spacing before and after itself. However, this code can be
disabled by using the \pkg{tcolorbox} keys \code{before} and \code{after} (along
with \code{width}, to make sure there's room). If we also want the boxes to have
the same height, we can use the key \code*{equal height group} (with some
arbitrary name):

\begin{texexp}
\begin{procedure}[after={}, width=.49\linewidth,
    equal height group=A]{}{}
\begin{pseudo}
Foo \\ Bar \\ Baz
\end{pseudo}
\end{procedure}
\hfill
\begin{procedure}[before={}, width=.49\linewidth,
    equal height group=A]{}{}
\begin{pseudo}
Frozz \\ Bozz
\end{pseudo}
\end{procedure}
\end{texexp}

\noindent
If the boxes are floats (i.e., either defined or used with the \pkg{tcolorbox}
key \code{float}, you can still use the \code*{equal height group} key. This is
useful, for example, in a twocolumn layout, if the boxes are at the top (or
bottom), one in each column.

Finally, if your boxes are floats in general, you're using a single-column
layout, and you want two boxes to float \emph{together}, side by side (e.g.,
because the pseudocode itself takes up little horizontal space), you can use the
first technique (setting \code{width}, \code{before} and \code{after}) along
with the \pkg{tcolorbox} key \code{nofloat}, and then place the boxes inside
some other float (such as a normal \LaTeX\@ \code{figure}, or a custom one using
the \pkg[https://ctan.org/tex-archive/macros/latex/contrib/float]{float}
package):

\begin{texexp}[listing]
\begin{figure}
\begin{procedure}[nofloat, after={}, width=.49\linewidth,
    equal height group=A]{}{}
\begin{pseudo}
    % ...
\end{pseudo}
\end{procedure}
\hfill
\begin{procedure}[nofloat, after={}, width=.49\linewidth,
    equal height group=A]{}{}
\begin{pseudo}
    % ...
\end{pseudo}
\end{procedure}
\end{figure}
\end{texexp}

\section{\dots\,have steps span multiple lines?}
\label{sec:multiline}

First of all, you can do this by just breaking your lines manually, keeping any
additional lines belonging to the same step unnumbered, by using the starred
version of \refc{\bslash} and skipping the number column with \code{\&}, adding
unnumbered lines:
\begin{texexp}
\begin{pseudo}[line-height=1.1]
  This step is broken\,\dots                    \\*&
  \dots\,into multiple lines                    \\
  This one is not
\end{pseudo}
\end{texexp}
If you want the line breaking to be automated, \emph{and you don't need
indentation}, you can use a \code{p} column, specified in \refk{preamble}
(perhaps defining a style using \refc{pseudodefinestyle}), adapted from the
default, as in the following.
\begin{note}
The default is
found on p.~\pageref{p:preamble}. However, in the source code there, whitespace
is insignificant. In writing your own preamble, you should avoid spurious
whitespace inside \code{>\braces{\dots}} and \code{<\braces{\dots}}.
\end{note}
\begin{texexp}
\begin{pseudo}[preamble = {
        >{\pseudohpad} \pseudolabelalign
        >{\pseudosetup} p{11.7cm} <{\pseudohpad}
    },
    setup-append = \raggedright\RestorePseudoBackslash,
    line-height = 1.5]
Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam
nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam
erat. \\
At vero eos et accusam et justo duo dolores et ea rebum. Stet
clita kasd gubergren, no sea takimata sanctus est Lorem ipsum
dolor sit amet.
\end{pseudo}
\end{texexp}

\noindent
In addition to introducing the \code{p} column, I've added \cs{raggedright} to
the setup (using \refk{setup-append}, with \cs{RestorePseudoBackslash} to
restore \refc{\bslash}, because \cs{raggedright} redefines it).

One disadvantage of the \code{p} column is that you need to know its exact
width. A better solution is probably to replace the default \code{tabular} with
a \code{tabularx}, as discussed in \cref{sec:tabularx}, and use an \code{X}
column, i.e.:\footnote{For an explanation of the use of \code{[t]}, see the
documentation of the \refk{pos} option.}
\begin{texexp}[listing]
    begin-tabular = \tabularx{\linewidth}[t]{
        >{\pseudohpad} \pseudolabelalign
        >{\pseudosetup} X <{\pseudohpad}
    },
    end-tabular = \endtabularx,
    setup-append = \RestorePseudoEq,
\end{texexp}

\noindent
The main problem with this setup is that the automatic line wrapping doesn't
take indentation into account, i.e., only the first line is indented! While
there are ways of dealing with this,\footnote{Cf.\
\url{https://github.com/mlhetland/pseudo.sty/issues/16}.} the simplest solution
(at least for now) is probably to break lines manually, using
\code{\cs{\bslash}*\&}.

\section{\dots\,get the old spacing?}

The current version of the \refe{pseudo} environment ensures the spacing above
and below is adjusted, so the baselines of the previous and following lines are
positioned equally, regardless of their depths or heights. If you'd rather have
the old behavior (which, frankly, was really a bug), you can get that as
follows:
\begin{texexp}
\pseudoset{pos = {}, prevdepth = 0pt}
\end{texexp}


\section{\dots\,configure my \code{tcolorbox}es?}
\label{sec:boxconfig}

If you use the \pkg{pseudo} styles for \code{tcolorbox}es (see
\cref{sec:floats}), you might still wish to do some tweaking, or even redefine
most of the styling. This is done using the \pkg{tcolorbox} configuration
system, not that of \pkg{pseudo}, so it's worth consulting the \pkg{tcolorbox}
documentation (and, perhaps, the source of the \pkg{pseudo} box styles, in
\cref{sec:floatsrc}). In the following, I go through some examples of things you
might want to adjust. First, let's define a rather unstyled environment which we
can modify locally.

% Duplicated:
\newtcbtheorem{example}{Example}{}{}
\begin{texexp}[listing]
\newtcbtheorem{example}{Example}{}{}
\end{texexp}

\begin{note}
If you want the styling to apply to the environment in general, simply insert it
as the third argument. See the \pkg{tcolorbox} documentation for more about
\cs{newtcbtheorem}.
\end{note}

\paragraph{A different separator.} By default, the \pkg{pseudo} box styles use
an \cs{enskip} to separate the label part from the description, but you might
want to use something else, such as a colon or a period. You can get this by
using the \code*{separator sign} key:
\begin{texexp}
\begin{example}[pseudo/ruled, separator sign = :]{\dots}{}
    \dots
\end{example}
\end{texexp}

\paragraph{A different parskip.} You might want more or less spacing between the
paragraphs of any plain text outside your pseudocode. You do this by setting
\cs{parskip}, which is normally set as part of the \code*{before upper} key in
the \code{pseudo/} styles (see p.~\pageref{p:before-upper}). Rather than
overwrite the \code*{before upper} code, you can use the hook \refk{pseudo/init}
(set as part of the \pkg{tcolorbox} configuration, not using \cs{pseudoset}):%
\begin{texexp}
\begin{example}[pseudo/boxed,
    pseudo/init = \parskip\baselineskip]{\dots}{}
    The parskip

    is bigger!
\end{example}
\end{texexp}
\begin{note}
It is possible to use the \pkg{tcolorbox} key \code*{before upper app}
(together with the \pkg{tcolorbox} library \code{hooks}) instead of
\refk{pseudo/init}. However, the compatibility code (\cref{sec:compat}) appends
some spacing to this setup hook, and this may be messed up by inserting more
code after it. In this case, \refk{pseudo/init} is safer.
\end{note}

You \emph{could} set \cs{topsep} and \cs{partopsep} in the same manner, but
unless you want to change the settings for lists (such as \code{itemize} and
\code{enumerate}), you could also just set those for pseudocode specifically,
using the \pkg{pseudo} keys \refk{topsep} and \refk{partopsep}, perhaps as part
of the \refk{in-float} style.

\bigskip

\paragraph{Different line widths.} If you start with \refk{pseudo/boxruled},
this is easy enough---you can just use the standard \pkg{tcolorbox} keys to
adjust the line widths.
\begin{texexp}
\begin{example}[pseudo/boxruled,
    boxrule = 4pt, titlerule = 2pt]{\dots}{}
    Now \emph{that's} a \emph{box}!
\end{example}
\end{texexp}
The problem with the other ruled or boxed styles is that they use the
\code{empty} skin, which removes the box drawing.
\begin{note}
The reason they don't just set the appropriate line widths to zero is that this
generally still results in visible hairlines in many PDF viewers.
\end{note}
\noindent
They then instead rely on various \code{borderline} commands. These are
cumulative, so if you want to replace some of them, you first need to clear the
deck with \code*{no borderline}, and then re-do them all. For example, maybe you
want a version of \refk{pseudo/tworuled} with light rules:
\begin{texexp}
\begin{example}[pseudo/tworuled,
    no borderline,
    toprule = \lightrulewidth,
    bottomrule = \lightrulewidth,
    borderline horizontal = {\lightrulewidth}{0pt}{black}]{\dots}{}
\dots
\end{example}
\end{texexp}
Note that even though the box rules aren't \emph{drawn}, they can still be used
for spacing---which the borderlines don't handle. In \code{pseudo/tworuled},
\code{toprule} and \code{bottomrule} are set to \cs{heavyrulewidth}, so since
we're replacing the horizontal borderlines with lighter ones, we need adjust
these as well. (If you do something similar with \refk{pseudo/ruled}, the width
of the title rule can still be changed by using the \code{titlerule} key, as in
the previous example.)

\bigskip

\paragraph{Different colors.} Again, customizing \code{pseudo/boxruled} is easy
enough; you can set the line colors using the \code{colframe}, and the fill
colors using \code{colback} and \code{colbacktitle}. The latter two keys also
work well with the \code{pseudo/filled} style (as shown in the example
\vpageref{ex:clrscode4ish}). To modify the line colors in the other styles,
you'll need borderline commands, again (though with separate styling for the
title rule). For example:
\begin{texexp}
\begin{example}[pseudo/booktabs,
    no borderline,
    titlerule style = lightgray,
    borderline horizontal = {\heavyrulewidth}{0pt}{gray}]{\dots}{}
\dots
\end{example}
\end{texexp}
If you want to style the top and bottom line separately, just use
\code*{borderline north} and \code*{borderline south} separately, rather than
the collective \code*{borderline horizontal}.

\chapter{Implementation}
\label{sec:impl}

\lstdefinestyle{tcblatex}{language={[LaTeX]TeX},
    aboveskip={0\p@ \@plus 6\p@},
    belowskip={0\p@ \@plus 6\p@},
    columns=fullflexible,
    keepspaces=true,
    breaklines=true,
    breakatwhitespace=true,
    basicstyle=\ttfamily\small\color{black!80},
    keywordstyle=,
    extendedchars=true,
    nolol,
    inputencoding=\kvtcb@listingencoding,
    literate=%
        {VERSION}{\pseudoversion}{3}%
        {REVISION}{\pseudorevision}{2}%
        {DATE}{\pseudodate}{10}%
        {~}{\textcolor{gray}{\raisebox{-.75ex}{\textasciitilde}}}{1},
    commentstyle=\color{gray},
}

\noindent
\textbf{Note:} In the following, \verb|_@@| and \verb|@@| represent
an internal prefix (\verb|__pseudo|), the same way they do with
\pkg{l3docstrip}.

\bigskip\noindent
First, we just define some metadata:
\begin{source}
\def \pseudoversion  {VERSION}
\def \pseudorevision {REVISION}
\def \pseudodate     {DATE}
\end{source}
The \pkg{pseudo} package is implemented using experimental \LaTeX\,3, so we
start by importing \pkg{expl3}:
\begin{source}
\RequirePackage{expl3}
\end{source}
Then we're ready start the package:
\begin{source}
\ProvidesExplPackage
    {pseudo}
    {\pseudodate}
    {\pseudoversion\pseudorevision}
    {Straightforward pseudocode}
\end{source}
Tools for defining user commands:
\begin{source}
\RequirePackage{xparse}
\end{source}
For defining \pkg{tcolorbox} styles, without importing \pkg{tcolorbox}:
\begin{source}
\RequirePackage{pgfkeys}
\end{source}
The \refe{pseudo} environment is built upon tabular functionality, and we're
using some extensions:
\begin{source}
\RequirePackage{array, xcolor, colortbl}
\end{source}
Though \emph{most} keys aren't available as \cs{usepackage} arguments, we
still use the mechanism:
\begin{source}
\RequirePackage{l3keys2e}
\end{source}
Inside the \refe{pseudo} environment, \refk{*} is an alias for
\refk{pseudoline}. To perform the proper aliasing, we use \pkg{aliascnt}:
\begin{source}
\RequirePackage{aliascnt}
\end{source}
As part of the initial setup, we also record whether we're part of a
\pkg{beamer} presentation; this will affect the overlay functionality:
\begin{source}
\bool_new:N \c_@@_beamer_bool
\@ifclassloaded{beamer}
    {\bool_set_true:N  \c_@@_beamer_bool}
    {\bool_set_false:N \c_@@_beamer_bool}
\end{source}
We're now ready to begin the actual implementation.

\section{Variable declarations}

Many variables are created as needed by various \code{set} commands, but some
are declared initially. First, we create a plain-vanilla \LaTeX\ counter for
the line number, as well as an outer one for the environment, the latter just
to avoid duplicate labels:
\begin{source}
\newcounter{pseudoenv}
\newcounter{pseudoline}[pseudoenv]
\end{source}
Eventually, we'll be saving the line counter so that \cs{label} commands will
work, but we'll only do so if the counter has \emph{changed} (again, to avoid
duplicate labels). To determine whether, in fact, it has, we keep the previous
one we saved:
\begin{source}
\int_new:N \g_@@_last_saved_line_int
\end{source}
Normally a counter is just saved when it's incremented (with
\cs{refstepcounter}), but in our case, we want to increment and typeset it
based on a (potentially) user-configured \refk{label}, and then actually save
it and make it the target of \cs{label} commands in a \emph{different scope}
(i.e., the next cell in the tabular row).

\bigpar

The indent size is set through the configuration key \refk{indent-length} (or
indirectly through \refk{indent-text}), while the current indent level is
manipulated by \refc{\bslash}; their product determines the actual length by
which the current line is indented. The initial indent level may be set using
\refk{indent-level}.
\begin{source}
\dim_new:N  \pseudoindentlength
\int_new:N  \g_@@_indent_level_int
\int_new:N  \l_@@_initial_indent_level_int
\end{source}

When handling unknown keys, we have special-casing of \refc{\bslash}, so we need
to know if that's the command we're in:
\begin{source}
\bool_new:N \l_@@_in_eol_bool
\end{source}

\section{Utilities}

\paragraph{Variants.} First, let's just generate a couple of expansion
variants we'll need of some standard commands. (I'm using the
\verb|\q_no_value| machinery rather than \verb|\c_novalue_tl| for
compatibility with older \TeX\ distributions.)
\begin{source}
\cs_generate_variant:Nn \quark_if_no_value:nTF    { VTF    }
\cs_generate_variant:Nn \tl_if_novalue:nTF        { VTF    }
\cs_generate_variant:Nn \tl_set:Nn                { Ne     }
\exp_args_generate:n                              { NNVNNV }
\end{source}
\paragraph{Defining columns.} The \refk{preamble} is is configurable, but the
\pkg{array} package makes sure it doesn't expand any part of its preamble. One
way of inserting a dynamically generated one is to simply define it all as a
single column type. To avoid getting an error when overwriting this definition
through the configuration, we'll also need to be able to \emph{un}-define column
types:
\begin{source}
\cs_new:Npn \@@_undef_col:n #1 {
    \tl_set_eq:cN { NC@find@ \token_to_str:N #1 } \scan_stop:
}
\end{source}
Note that the implementation specifically targets the \pkg{array} package. The
following command then will either define or \emph{re}-define a column type:
\begin{source}
\cs_new:Npn \@@_def_col:nn #1 #2 {
    \@@_undef_col:n { #1 }
    \newcolumntype  { #1 } { #2 }
}
\end{source}
%
\paragraph{Defining commands.}
This command creates a new command with a \code{pseudo} prefix, and defines
the prefixless version as well, \emph{if the name is available} (i.e.,
undefined):
\begin{source}
\cs_new:Npn \@@_meta_new_cmd:NNnn #1 #2 #3 #4 {
    \tl_set:Nn \l_tmpa_tl {pseudo \cs_to_str:N #2}
    \exp_args:Nc
        #1 \l_tmpa_tl #3 {#4}
    \cs_if_free:NT #2 {\cs_gset_eq:Nc #2 \l_tmpa_tl}
}

\cs_new:Npn \@@_new_cmd:Nnn #1 #2 #3 {
    \@@_meta_new_cmd:NNnn
    \NewDocumentCommand #1 {{#2}} {
        #3
    }
}

\cs_new:Npn \@@_new_ecmd:Nnn #1 #2 #3 {
    \@@_meta_new_cmd:NNnn
    % \NewExpandableDocumentCommand #1 {{#2}} {
    % Replaced for compatibility:
    \def #1 {#2} {
        #3
    }
}
\end{source}
This is for defining commands that declare styled shortcuts:
\begin{source}
\cs_new:Npn \@@_new_dec:nn #1 #2 {
    \tl_set:Nn \l_tmpa_tl { DeclarePseudo #1 }
    \exp_args:Nc
    \DeclareDocumentCommand \l_tmpa_tl { mm } {
        \DeclareDocumentCommand ##1 { } {
            \use:c { #2 } { ##2 }
        }
    }
}
\end{source}
You use this with a capitalized name for the kind of thing you're declaring,
and the name of the style command to use. For example,
\begin{center}
\verb|\@@_new_dec:nn{Keyword}{kw}|
\end{center}
will create the command \cs{DeclarePseudoKeyword}, which takes a csname and a
word, and binds the csname as a shortcut for the word, properly styled as a
keyword.

\bigskip

\paragraph{Argument parsing.} In processing the multiple \code{+} and \code{-}
arguments to \refc{\bslash}, we'll gobble up one character at a time, each
time performing some action. We also supply code to be performed once we're
done.
\begin{source}
\cs_new:Npn \@@_per_char:nnn #1 #2 #3 {
    \peek_charcode_remove:NTF { #1 } {
        #2 % body
        \@@_per_char:nnn{#1}{#2}{#3}
    } {
        #3 % tail
    }
}
\end{source}
%
\paragraph{Indentation.} The indent size (i.e., the length of a single
step of indentation) is either set directly through \refk{indent-length}, or
indirectly through \refk{indent-text}. The latter is there the default is
provided, but \refk{indent-text} is only used if there is no \refk{indent-length}.
\begin{source}
\cs_new:Npn \@@_set_indent_length: {

    \quark_if_no_value:VTF \l_@@_indent_length_tl {
        \hbox_set:Nn \l_tmpa_box { \l_@@_indent_text_tl }
        \dim_set:Nn \pseudoindentlength { \box_wd:N \l_tmpa_box }
    } {
        \dim_set:Nn \pseudoindentlength \l_@@_indent_length_tl
    }

}
\end{source}
Note that the configured indent length is stored in a \code{tl}, which is
expanded in the \refe{pseudo} environment.

The indent size is subsequently used by the indent command, which takes the
number of indentation steps as its only argument. If no \refk{indent-mark} is
set, it just inserts an appropriate horizontal space. Otherwise, it iterates
over the indent levels, inserting one indent marker for each level. Note that to
avoid affecting the indent, the \refk{indent-mark} should have no width (i.e.,
it should ``undo'' the width of any text it contains, using \cs{rlap}, a
negative \cs{hspace} or the like).
\begin{source}
\cs_new:Npn \@@_indent:N #1 {
    \tl_if_novalue:VTF \l_@@_indent_mark_tl {
        \skip_horizontal:n{ \pseudoindentlength * #1 }
    } {
        \group_begin:
        \color{\l_@@_indent_color_tl}
        \int_step_inline:nn { \g_@@_indent_level_int } {
            \l_@@_indent_mark_tl
            \skip_horizontal:n{ \pseudoindentlength }
        }
        \group_end:
    }
    \ignorespaces
}
\end{source}
%
\paragraph{Counter copying.} Inside the \refe{pseudo} environment, we want
\code{*} to be a duplicate of \code{pseudoline}, for convenience. This requires
a bit of work. We use the \pkg{aliascnt} package to deal with much of the
book-keeping, but in order for \cs{newaliascnt} to work whenever a counter
already exists, we need to undefine it first. (Here we're relying on the
internal \LaTeX\ convention of using \verb|c@| as a prefix to counter names.)

\begin{source}
\cs_new:Npn \@@_drop_ctr:n #1 {
    \cs_undefine:c { c@ #1 }
}

\cs_new:Npn \@@_copy_ctr:nn #1 #2 {
    \@@_drop_ctr:n { #1 }
    \newaliascnt   { #1 } { #2 }
}

\cs_new:Npn \@@_star_setup: {

    \cs_if_exist:cT { c@ * } {
        \@@_copy_ctr:nn { @@_orig_* } { * }
    }
    \@@_copy_ctr:nn { * } { pseudoline }

    \group_insert_after:N \@@_star_reset:

}

\cs_new:Npn \@@_star_reset: {
    \cs_if_exist:cT { c@ @@_orig_* } {
        \@@_copy_ctr:nn { * } { @@_orig_* }
        \cs_undefine:c { c@ @@_orig_* }
    }
}
\end{source}
%
\paragraph{Label saving.}
In the body of each line, we make sure to save the counter, so it's available
for the \cs{label} command. We've aready incremented \code{pseudoline} with
\cs{stepcounter} in the label, so we first need to decrement it before we
again increment it, this time with \cs{refstepcounter}. However, we only do so
if the counter actually \emph{was} incremented, i.e., if it's different from
the last one we saved.
\begin{source}
\cs_new:Npn \@@_save_label: {

    \int_set:Nn \l_tmpa_int {\arabic{pseudoline}}

    \int_compare:nF {\l_tmpa_int = \g_@@_last_saved_line_int} {
        \addtocounter{pseudoline}{-1}
        \refstepcounter{pseudoline}
        \int_gset_eq:NN \g_@@_last_saved_line_int \l_tmpa_int
    }

}

\DeclareDocumentCommand \pseudosavelabel { } {
    \@@_save_label:
}
\end{source}
%
\paragraph{Saving and restoring.} In general, we could just use local
variables and trust the scope mechanism, but if we use global assignments
inside the scope (e.g., because of where in a tabular we must assign things
and use them), the original meaning \emph{won't} be restored. Of course, this
should \emph{not} be used if assignments are local, as it will globally set
the original name to the meaning it had when we entered the scope.

In saving a macro, we also supply a name for the original, which may then be
used to refer to it until it's restored.
\begin{source}
\cs_new:Npn \@@_cs_gsave_as:NN #1 #2 {
    \cs_gset_eq:NN #2 #1
    \group_insert_after:N \cs_gset_eq:NN
    \group_insert_after:N #1
    \group_insert_after:N #2
}
\end{source}
%
\paragraph{Skipping paragraphs.} Ignoring space is easy enough, but skipping
\cs{par} tokens takes a bit more work. We'll be using this as part of the
end-of-line handling, when we're checking if the next ``real'' token is
\cs{end}. The argument is the code to execute after skipping (and removing)
whitespace and \cs{par} tokens.
\begin{source}
\cs_new:Npn \@@_skip_pars:n #1 {
    \peek_meaning_remove_ignore_spaces:NTF \par {
        \@@_skip_pars:n { #1 }
    } {
        #1
    }
}
\end{source}
%
\section{Styles}

The first text styling commands are only straight-up shortcuts for normal font
commands:
\begin{source}
\@@_new_cmd:Nnn \nf {   } { \normalfont          }
\@@_new_cmd:Nnn \tn { m } { \textnormal { #1 }   }
\@@_new_cmd:Nnn \kw { m } { \textnormal {\kwfont { #1 } } }
\@@_new_cmd:Nnn \cn { m } { \textnormal {\cnfont { #1 } } }
\@@_new_cmd:Nnn \id { m } { \textnormal {\idfont { #1 } } }
\end{source}
\begin{note}
As a side-effect, we've now also defined \cs{pseudonf} and \cs{pseudotn}, which
we don't really need, as we might as well use \cs{normalfont} and
\cs{textnormal} directly.
\end{note}

\noindent
While we're at it, we'll define the initial value for \refc{kwfont}, which is
generally non-extended bold, if that's available, but extended bold otherwise:
\begin{source}
\cs_new:Npn \@@_b_or_bx: {

    % Note: We're relying on the warning text in \@defaultsubs
    % being defined by \selectfont if the desired font isn't
    % found. This won't happen, however, if the same
    % \curr@fontshape combination has been attempted before
    % (cf. source2e.pdf page 179).

    \group_begin:

    \cs_if_exist:NT \@defaultsubs {
        \@@_cs_gsave_as:NN \@defaultsubs \@@_defaultsubs
        \cs_gset_eq:NN \@defaultsubs \relax
    }

    % This is what we'd like:
    \cs_gset:Nn \@@_b_or_bx: { \fontseries{b}\selectfont }

    % Try it:
    \@@_b_or_bx:

    % Fallback, if that failed:
    \cs_if_exist:NT \@defaultsubs {
        \cs_gset_eq:NN \@@_b_or_bx: \bfseries
    }

    \group_end:

    % Make sure the new version is used:
    \@@_b_or_bx:

}
\end{source}
Note that the command redefines itself after the first use, so as not to
execute the check every time.

The \refc{pr} command is also a font shortcut, but in addition takes optional
parenthesis-delimited arguments, which are set in math mode. To avoid
erroneousy slurping up following parentheticals, there should be no space
separating the command and its optional argument. With current versions of
\pkg{xparse}, this can be achieved with the \verb|!| argument type, but for
compatibility with older \TeX\ distributions, I'll deal with it ``manually''.
\begin{source}
\cs_new:Npn \@@_fmt_pr:n #1 {
    \textnormal{\prfont{ #1 }}
}

\NewDocumentCommand \@@_parse_paren_args { +d() } {
    \IfNoValueF { #1 } {
        \ensuremath{ ( #1 ) }
    }
}

\NewDocumentCommand \@@_parse_bracket_or_paren_args { +o } {
    \IfNoValueTF { #1 } {
        \@@_parse_paren_args
    } {
        \ensuremath{ [ #1 ] }
    }
}

\@@_new_cmd:Nnn \pr { m } {
    \@@_fmt_pr:n { #1 }
    \peek_catcode:NTF { ~ } { } {
        \@@_parse_paren_args
    }
}
\end{source}
The \refc{fn} command is similar, but alternatively permits arguments in
square brackets.
\begin{source}
\cs_new:Npn \@@_fmt_fn:n #1 {
    \textnormal{\fnfont{ #1 }}
}
\@@_new_cmd:Nnn \fn { m } {
    \@@_fmt_fn:n { #1 }
    \peek_catcode:NTF { ~ } { } {
        \@@_parse_bracket_or_paren_args
    }
}
\end{source}
The \refc{hd} command is similar to \refc{pr} command, except that it spans
two columns (effectively ignoring the labeling column). Because it needs to be
expandable in order to insert the multicolumn, the final, parenthesis-enclosed
argument can not be optional (unlike for \refc{pr}). Note also that \refc{hd}
sets \refk{extra-space} (or the underlying \code{tl}) based on \refk{hd-space}.
\begin{source}
% \@@_new_ecmd:Nnn \hd { m +r() } {
% Now uses \def syntax:
\@@_new_ecmd:Nnn \hd { #1 ( #2 ) } {
    \multicolumn{2}
        {\pseudohdpreamble}
        {\@@_fmt_pr:n{#1}\ensuremath{(#2)}}
        \tl_set_eq:NN \l_@@_extra_space_tl \l_@@_hd_space_tl
}
\end{source}
Finally, \refc{st} and \refc{ct} add quotes and comment delimiters,
respectively, to the typeset string, keeping it all in \cs{textnormal}:
\begin{source}
\@@_new_cmd:Nnn \st { +m } {
    \textnormal {
    \l_@@_st_left_tl {\stfont{#1}} \l_@@_st_right_tl }
}
\@@_new_cmd:Nnn \ct { +m } {
    \textnormal {
    \l_@@_ct_left_tl {\ctfont{#1}} \l_@@_ct_right_tl }
}
\end{source}
Beyond text styling, we also have styling for entire rows, i.e., highlighting:
\begin{source}
% \NewExpandableDocumentCommand \pseudohl { } {
% For backward compatibility:
\def \pseudohl {
    \rowcolor{\pseudohlcolor}
}
\end{source}
%
\paragraph{Declarations.} To declare shortcuts using the various styles,
commands  la \code{DeclareMathOperator} and \code{DeclareDocumentCommand} are
provided:
\begin{source}
\@@_new_dec:nn { Comment    } { ct }
\@@_new_dec:nn { Constant   } { cn }
\@@_new_dec:nn { Function   } { fn }
\@@_new_dec:nn { Identifier } { id }
\@@_new_dec:nn { Keyword    } { kw }
\@@_new_dec:nn { Normal     } { tn }
\@@_new_dec:nn { Procedure  } { pr }
\@@_new_dec:nn { String     } { st }
\end{source}
%
\section{Notation}

Here we'll define a couple of symbols that are useful for pseudocode but that
are not necessarily entirely standard mathematical notation. First, the double
equals sign, ubiquitous in modern programming languages, and useful if
\code{=} is used for assignment. The horizontal scaling of the equals signs,
as well as the space between them and the padding on both sides may be
adjusted by using the keys \refk{eqs-scale}, \refk{eqs-sep} and
\refk{eqs-pad}. Initially, these are set to emulate the \cs{eqeq} symbol from
\pkg{stix} when used with Computer Modern, Latin Modern or the like (though the
command works just fine with other fonts as well).
\begin{source}
\@@_new_cmd:Nnn \eqs { } {
    \group_begin:
    \muskip_set:Nn \l_tmpa_muskip \l_@@_eqs_pad_tl
    \muskip_set:Nn \l_tmpb_muskip \l_@@_eqs_sep_tl
    \hbox_set:Nn   \l_tmpa_box {\(=\)}
    \box_scale:Nnn \l_tmpa_box {\l_@@_eqs_scale_fp}{1}
    \mathrel{
        \tex_mskip:D     \l_tmpa_muskip
        \box_use:N       \l_tmpa_box
        \tex_mskip:D     \l_tmpb_muskip
        % \box_use_drop:N  \l_tmpa_box
        % Replaced for compatibility
        \box             \l_tmpa_box
        \tex_mskip:D     \l_tmpa_muskip
    }
    \group_end:
}
\end{source}
For convenience and source-code clarity, the following shortcut (i.e.,
\cs{==}) is defined (hijacking the \cs{=} accent command):
\begin{source}
\cs_gset_eq:NN \c_@@_orig_eq_cs \=

\DeclareDocumentCommand \= { m } {
    \tl_if_eq:nnTF { #1 } { = } {
        \l_@@_eqs_impl_tl
    } {
        \c_@@_orig_eq_cs{#1}
    }
}

\cs_gset_eq:NN \@@_eq: \= % Stored for \RestorePseudoEq
\end{source}
Similarly, there's the
\href{https://proofwiki.org/wiki/Definition:Real_Interval/Notation/Wirth}{Pascal
two-dot interval notation}, whose implementation mirrors Knuth's \cs{dts}
command from Concrete Mathematics (see \pkg{gkpmac.tex}), with the addition of
\cs{nolinebreak}, taken from
\pkg[https://www.cs.dartmouth.edu/~thc/]{clrscode4e}.

\begin{source}
\@@_new_cmd:Nnn \dts { } {
    \nolinebreak
    \mathinner {
        \ldotp
        \ldotp
    }
    \nolinebreak
}
\end{source}
%
There's a shortcut (\cs{..})\@ defined for this as well (this time hijacking
\cs{.}):
\begin{source}
\cs_gset_eq:NN \c_@@_dot_cs \.

\DeclareDocumentCommand \. { m } {
    \tl_if_eq:nnTF { #1 } { . } {
        \l_@@_dts_impl_tl
    } {
        \c_@@_dot_cs { #1 }
    }
}
\end{source}
%
Finally, we define a different syntax for numeric ranges like these (or
\emph{slices} or \emph{subarrays}). This command is based on the \cs{subarr}
command of \pkg[https://www.cs.dartmouth.edu/~thc/]{clrscode4e}.
\begin{source}
\@@_new_cmd:Nnn \rng { } {
    \nolinebreak
    \mathinner { : }
    \nolinebreak
}
\end{source}

\section{Options}
\label{sec:options}

Much of the behavior of \pkg{pseudo} may be configured through various options,
and these are defined below. You provide these either through \refc{pseudoset}
or (where applicable) as optional arguments to \refc{\bslash} or the
\refe{pseudo} environment itself.

The \cs{usepackage} options (handled by \pkg{l3keys2e}) are subject to full
expansion, an so many options simply won't work. In order to make the \refk{kw}
option as easily available as possible, however, we permit it here, by way of a
\code{bool} that triggers the \emph{actual} key later on:

\begin{source}
\keys_define:nn { pseudo/package } {
    kw              .bool_gset:N    = \g_@@_kw_bool,
    kw              .default:n      = true
}
\ProcessKeysOptions{ pseudo/package }
\end{source}
%
We now define the actual keys used by \refc{pseudoset}. Note that \refk{hpad}
and \refk{hsep} do \emph{not} use \verb|.dim_set:N|. This is because the
\code{dim} would then be interpreted at the point where it's \emph{set}, and
not where it's \emph{used}. If we use units like \code{em} and \code{ex},
which depend on the font and font size, the spacing would not be updated if we
change these things between setting \code{hpad} and \code{hsep} and actually
typesetting the pseudocode.

\begin{source}
\keys_define:nn { pseudo } {

    init            .tl_set:N       = \l_@@_init_tl,
    init-append     .code:n         = {
        \tl_put_right:Nn \l_@@_init_tl {#1}
    },
    init-prepend    .code:n         = {
        \tl_put_left:Nn \l_@@_init_tl {#1}
    },

    font            .tl_set:N       = \pseudofont,
    font            .initial:n      = \normalfont,

    hpad            .meta:n         = {
        hpad-val = { #1 },
        hl-warn = false,
    },
    hpad            .default:n      = 0.3em,

    % For internal use:
    hpad-val        .tl_set:N       = \l_@@_hpad_tl,
    hpad-val        .initial:n      = 0.0em,

    hsep            .tl_set:N       = \l_@@_hsep_tl,
    hsep            .initial:n      = .75em,

    left-margin     .tl_set:N       = \l_@@_left_margin_tl,
    left-margin     .initial:n      = 0pt,

    label           .tl_set:N       = \l_@@_label_tl,
    label           .initial:n      = \arabic*,

    label-align     .code:n         =
        \@@_def_col:nn{ \pseudolabelalign }{#1},
    label-align     .initial:n      = r,

    ref             .tl_set:N       = \thepseudoline,
    ref             .default:n      = \l_@@_label_tl,

    indent-length   .tl_set:N       = \l_@@_indent_length_tl,
    indent-length   .initial:V      = \q_no_value,

    indent-text     .tl_set:N       = \l_@@_indent_text_tl,
    indent-text     .initial:n      = { \pseudofont\kw{else}\ },

    indent-mark     .tl_set:N       = \l_@@_indent_mark_tl,
    indent-mark     .initial:x      = \c_novalue_tl,
\end{source}
The default \refk{indent-mark} is a vertical rule with width set by
\refk{indent-mark-width}, followed by a negative horizontal space of the same
magnitude.
\begin{source}
    indent-mark     .default:n      =
        \skip_horizontal:n { \l_@@_indent_mark_shift_tl }
        \tex_vrule:D width \l_@@_indent_mark_wd_tl
        \skip_horizontal:n {
            -\l_@@_indent_mark_wd_tl
            -\l_@@_indent_mark_shift_tl
        },

    indent-mark-width .tl_set:N     = \l_@@_indent_mark_wd_tl,
    indent-mark-width .initial:n    = \c_@@_semithick_dim,

    indent-mark-shift .tl_set:N     = \l_@@_indent_mark_shift_tl,
    indent-mark-shift .initial:n    = 0pt,
    indent-mark-shift .default:n    = .5em,

    indent-mark-color .tl_set:N     = \l_@@_indent_color_tl,
    indent-mark-color .initial:n    = lightgray,

    indent-level    .int_set:N      = \l_@@_initial_indent_level_int,

    kwfont          .tl_set:N       = \kwfont,
    kwfont          .initial:n      = \@@_b_or_bx:,

    kw              .meta:n         = { font = \kwfont },
    kw              .value_forbidden:n = true,

    hl-warn         .bool_set:N     = \l_@@_hl_warn_bool,
    hl-warn         .initial:n      = true,
    hl-warn         .default:n      = true,

    % For internal use:
    hl-warn-code    .code:n         = {
        \bool_if:nT \l_@@_hl_warn_bool {
            \msg_warning:nn { pseudo } { hl-without-hpad }
        }
    },

    hl              .meta:n         = {
        hl-warn-code,
        bol-prepend = \pseudohl
    },
    hl              .value_forbidden:n = true,

    bol             .tl_set:N       = \l_@@_bol_tl,
    bol-append      .code:n         = {
        \tl_put_right:Nn \l_@@_bol_tl {#1}
    },
    bol-prepend     .code:n         = {
        \tl_put_left:Nn \l_@@_bol_tl {#1}
    },

    eol             .tl_set:N       = \l_@@_eol_tl,
    eol-append      .code:n         = {
        \tl_put_right:Nn \l_@@_eol_tl {#1}
    },
    eol-prepend     .code:n         = {
        \tl_put_left:Nn \l_@@_eol_tl {#1}
    },

    % Defined differently in beamer -- see below
    pause           .meta:n         = ,
    pause           .value_forbidden:n = true,

    cnfont          .tl_set:N       = \cnfont,
    cnfont          .initial:n      = \textsc,

    idfont          .tl_set:N       = \idfont,
    idfont          .initial:n      = \textit,

    stfont          .tl_set:N       = \stfont,
    stfont          .initial:n      = \textnormal,

    st-left         .tl_set:N       = \l_@@_st_left_tl,
    st-left         .initial:n      = ``,

    st-right        .tl_set:N       = \l_@@_st_right_tl,
    st-right        .initial:n      = '',

    prfont          .tl_set:N       = \prfont,
    prfont          .initial:n      = \cnfont,

    fnfont          .tl_set:N       = \fnfont,
    fnfont          .initial:n      = \idfont,

    ctfont          .tl_set:N       = \ctfont,
    ctfont          .initial:n      = \textit,

    ct-left         .tl_set:N       = \l_@@_ct_left_tl,
    ct-left         .initial:n      = (,

    ct-right        .tl_set:N       = \l_@@_ct_right_tl,
    ct-right        .initial:n      = ),

    hl-color        .tl_set:N       = \pseudohlcolor,
    hl-color        .initial:n      = black!12,

    dim-color       .tl_set:N       = \pseudodimcolor,
    dim-color       .initial:n      = \pseudohlcolor,

    dim             .meta:n         = {
        bol-append   = \color{\pseudodimcolor},
        setup-append = \color{\pseudodimcolor}
    },

    line-height     .tl_set:N       = \l_@@_line_height_tl,
    line-height     .initial:n      = 1,

    extra-space     .tl_set:N       = \l_@@_extra_space_tl,
    extra-space     .initial:n      = 0pt,

    hd-space        .tl_set:N       = \l_@@_hd_space_tl,
    hd-space        .initial:n      = 0pt,
\end{source}
The default value here emulates the spacing used in
\pkg[https://www.cs.dartmouth.edu/~thc/]{clrscode4e}, though with a different
mechanism:\footnote{They insert
\code{\cs{rule}[-1.25ex]\braces{0pt}\braces{0pt}} as part of the header.}
\begin{source}
    hd-space        .default:n      = 0.41386ex,

    start           .tl_set:N       = \l_@@_start_tl,
    start           .initial:n      = 1,
\end{source}
%
\paragraph{Line structure.} The preamble for the internal \code{tabular} is
defined as a single column type, to make it easier to apply it despite the
\pkg{array} protections against expansion.
\begin{source}
    preamble        .code:n         =
        \@@_def_col:nn{ \pseudopreamble }{#1},
\end{source}
The preamble is laid out as described in \cref{sec:reference}:
\label{p:preamble}%
\begin{source}
    preamble        .initial:n      = {
        >{ \pseudohpad }
        \pseudolabelalign
        >{ \pseudosetup }
        l
        <{ \pseudohpad }
    },
    setup           .tl_set:N       = \l_@@_setup_tl,
    setup           .initial:n      = {
        \pseudoindent \pseudofont \pseudosavelabel
    },

    setup-append    .code:n         = {
        \tl_put_right:Nn \l_@@_setup_tl {#1}
    },
    setup-prepend   .code:n         = {
        \tl_put_left:Nn \l_@@_setup_tl {#1}
    },
\end{source}
The preamble used for multicolumns is treated similarly:
\label{p:hdpreamble}%
\begin{source}
    hd-preamble     .code:n         =
        \@@_def_col:nn{ \pseudohdpreamble }{#1},
    hd-preamble     .initial:n      = {
        >{ \pseudohpad } l <{ \pseudohpad }
    },
\end{source}
The prefix is inserted by the row separator command.
\label{p:prefix}%
\begin{source}
    prefix          .tl_set:N       = \pseudoprefix,
    prefix          .initial:n      = {
        \pseudobol \stepcounter* \pseudolabel &
    },
\end{source}
\paragraph{Tabular setup.}
The beginning and end of the tabular environment, as well as some positioning
and spacing.
\begin{source}
    pos             .tl_set:N       = \pseudopos,
    pos             .initial:n      = t,

    prevdepth       .tl_set:N       = \l_@@_prevdepth_tl,
    prevdepth       .initial:n      = .3 \baselineskip,

    begin-tabular   .tl_set:N       = \l_@@_begin_tabular_tl,
    begin-tabular   .initial:n      =
        \begin{tabular}[\pseudopos]{\pseudopreamble},

    end-tabular     .tl_set:N       = \l_@@_end_tabular_tl,
    end-tabular     .initial:n      = \end{tabular},
\end{source}
\paragraph{List-like spacing.} Space above and below is handled similarly to
in the built-in \LaTeX\ lists, with the option of locally overriding
\cs{topsep} and \cs{partopsep}, with \refk{compact} used to control the presence
of this spacing (overriding the ordinary automatic choice based on the current
mode).
\begin{source}
    topsep          .tl_set:N       = \l_@@_topsep_tl,
    topsep          .initial:n      = { \topsep },

    partopsep       .tl_set:N       = \l_@@_partopsep_tl,
    partopsep       .initial:n      = { \partopsep },

    compact         .meta:n         = {
        compact-val  = { #1 },
        compact-def  = true,
        compact-code = { #1 },
    },
    compact         .default:n      = true,

    % For internal use:
    compact-val     .bool_set:N     = \l_@@_compact_bool,
    compact-def     .bool_set:N     = \l_@@_compact_def_bool,
    compact-code    .code:n         = {
        \bool_if:nT { \l_@@_compact_bool } {
            \tl_clear:N \pseudopos
        }
    },
\end{source}

\paragraph{Notation.} The commands \refc{==} and \refc{..} normally produce
$\..$ and $\==$, via \refc{eqs} and \refc{dts} (in their fully prefixed
versions, \cs{pseudoeqs} and \cs{pseudodts}). Because of the implementation of
these commands, you can't simply replace their implementation directly with
\cs{def} or \cs{let}. Instead, you can use these keys to replace the necessary
internal code.
\begin{source}
    eqs-impl        .tl_set:N       = \l_@@_eqs_impl_tl,
    eqs-impl        .initial:n      = { \pseudoeqs },

    dts-impl        .tl_set:N       = \l_@@_dts_impl_tl,
    dts-impl        .initial:n      = { \pseudodts },
\end{source}

\paragraph{Details.} Finally, some tweakable parameters.
\begin{source}
    eqs-scale       .fp_set:N       = \l_@@_eqs_scale_fp,
    eqs-scale       .initial:n      = 0.6785,

    eqs-sep         .tl_set:N       = \l_@@_eqs_sep_tl,
    eqs-sep         .initial:n      = 0.63mu,

    eqs-pad         .tl_set:N       = \l_@@_eqs_pad_tl,
    eqs-pad         .initial:n      = 0.28mu,

}
\end{source}
%
Now that we've defined the real \refk{kw} key, we reexamine the placeholder
handled by \pkg{l3keys2e}:
\begin{source}
\bool_if:NT \g_@@_kw_bool {
    \keys_set:nn { pseudo } { kw }
}
\end{source}
%
\paragraph{Beamer overlays.}
We redefine the \refk{pause} key if we're using \pkg{beamer}:
\begin{source}
\bool_if:NT \c_@@_beamer_bool {
    \keys_define:nn { pseudo } {
        pause .meta:n = { eol-append = \pause }
    }
}
\end{source}
There's also the mechanism for handling overlay specifications on keys. Here we
handle unknown keys by checking if they end with an overlay specification, and
if they do, and we're in \pkg{beamer}, we extract it. Outside \pkg{beamer}, keys
with overlays are simply ignored.

Note that because unknown keys currently can't have a default (which we could,
in this case, use for some kind of marker, indicating no value was supplied),
the only solution is to treat an empty value the same way as no value, in this
case. This means that \code{foo<1>} and \code{foo<1>=\braces{}} are
equivalent, and both will trigger the default of \code{foo}, even though the
latter of the two really shouldn't.\footnote{See
\url{https://github.com/latex3/latex3/issues/67}.}
\begin{source}
\cs_new:Npn \@@_keys_set_overlay:nnn #1 #2 #3 {
    \bool_if:NT \c_@@_beamer_bool {
        \tl_if_novalue:nF { #1 } {
            \only<#1>{ \keys_set:nn { #2 } { #3 } }
        }
    }
}

\msg_new:nnn { pseudo } { unknown-key } {
    Unknown~key~'#1'~ignored.
}

\tl_new:N \l_@@_overlay_tl

\keys_define:nn { pseudo } {
    unknown .code:n = {

        \group_begin:

        \int_zero:N \l_tmpa_int
        \int_zero:N \l_tmpb_int

        \tl_clear:N \l_tmpa_tl
        \tl_clear:N \l_tmpb_tl

        \tl_map_inline:Nn \l_keys_key_tl {

            \tl_if_eq:nnTF { ##1 } { < } {

                \int_incr:N \l_tmpa_int
                \int_compare:nF { \l_tmpb_int == 0 } {
                    % We already found `>'!
                    % Increment again to prevent match:
                    \int_incr:N \l_tmpa_int
                }

                \tl_set_eq:NN \l_tmpb_tl \l_tmpa_tl
                \tl_clear:N \l_tmpa_tl

            } {

            \tl_if_eq:nnTF { ##1 } { > } {

                \int_incr:N \l_tmpb_int

                \tl_set_eq:NN \l_@@_overlay_tl \l_tmpa_tl
                \tl_clear:N \l_tmpa_tl

            } {

                \tl_put_right:Nn \l_tmpa_tl { ##1 }

            } }

        }

        % A single `<' and a final, single `>'?
        \bool_if:nTF {
            \int_compare_p:n { \l_tmpa_int == \l_tmpb_int == 1 }
            &&
            \tl_if_empty_p:N \l_tmpa_tl
        } {
\end{source}
We've matched a key with an overlay specification. If it's got a (non-blank)
value, we include that in the key-setting code we're building in
\cs{l\_tmpb\_tl}, and then we set the key, with the appropriate overlay
specification.
\begin{source}
            \tl_if_blank:nF{ #1 } {
                \tl_put_right:Nn \l_tmpb_tl {= #1}
            }
\end{source}
Rather than setting the keys here, inside a group, we put the code into a
variable that we'll expand outside the group, later:
\begin{source}
            \tl_set:Nn \l_tmpa_tl {
                \@@_keys_set_overlay:nnn
            }
            \tl_put_right:Nx \l_tmpa_tl { { \l_@@_overlay_tl } }
            \tl_put_right:Nn \l_tmpa_tl { { pseudo           } }
            \tl_put_right:Nx \l_tmpa_tl { { \l_tmpb_tl       } }
        } {
\end{source}
We have \emph{not} matched an overlay specification, so we just have an unknown
key. However, we have another special case to consider: If we're processing
arguments to \refc{\bslash}, we also permit a keyless value to be used to
specify extra space (normally done using \refk{extra-space}). If the unknown
key doesn't have an attached (non-blank) value, we treat the key itself as a
value, and use it as extra space. If this, too, fails, we emit an error message.
Note that we'll also make sure the variable with the key-setting code is
empty.
\begin{source}
            \tl_clear:N \l_tmpa_tl
            \bool_if:nTF {
                \bool_lazy_and_p:nn
                    { \l_@@_in_eol_bool       }
                    { \tl_if_blank_p:n { #1 } }
            } {
                \tl_set_rescan:Nno
                    \l_@@_extra_space_tl { }
                    { \l_keys_key_str  }
            } {
                \msg_error:nnx
                    { pseudo } { unknown-key }
                    { \l_keys_path_str }
            }
        }

        % Make sure extra space and key-setting carry over
        % outside the group:
        \exp_args:NNNVNNV
            \group_end:
            \tl_set:Nn \l_@@_extra_space_tl \l_@@_extra_space_tl
            \tl_set:Nn \l_tmpa_tl           \l_tmpa_tl

        % Run the key-setting code with overlay specification:
        \l_tmpa_tl

    }

}
\end{source}
%
\paragraph{Option processing.} To let the user work with the options (other
than when they're available as optional arguments to other commands), we
supply a command for setting them.
\begin{source}
\cs_new:Npn \@@_set:n #1 { \keys_set:nn { pseudo } { #1 } }
\end{source}
%
\section{The row separator}

Much of the work of the \refe{pseudo} environment is performed by the row
separator, that is, the \refc{\bslash} command; whatever part of the line
structure (see \cref{sec:reference}) that's not in the \refk{preamble} must be
handled by \refc{\bslash}. For example, this is where the \refk{prefix} gets
inserted. One reason for this is that there is no straightforward way to
insert the column separator (\code{\&}) from the \refk{preamble} itself; and
if you want to prevent the column separator insertion because you need to to
some custom work in the first column, you'll probably want to suppress other
parts of the \refk{prefix} as well, so they might as well be collected in one
place.

Beyond inserting material such as \cs{tabularnewline}s and \refk{prefix}
contents, \refc{\bslash} is also an entrypoint for local customization, i.e.,
modifying the indentation level and setting any locally meaningful keys.

\bigskip

\paragraph{Indentation utilities.} First we have some functions for modifying
the indentation level---essentially just incrementing, decrementing and
setting it to zero.
\begin{source}
\cs_new:Npn \@@_inc_indent: {
    \int_gincr:N \g_@@_indent_level_int
}

\cs_new:Npn \@@_dec_indent: {
\end{source}
If the user happens to dedent too much, we might as well be a bit forgiving,
and clamp the indent level to non-negative values:
\begin{source}
    % Not using \c_zero_int for compatibility
    \int_compare:nNnT \g_@@_indent_level_int > 0 {
        \int_gdecr:N \g_@@_indent_level_int
    }
}
\end{source}
%
\paragraph{The actual row separator.} The command consists of a few
interacting macros. The implementation of \refc{\bslash} is
\verb|\@@_eol:|, but that is just a thin wrapper that counts pluses and
minuses, before handing the control over to \verb|\@@_eol_tail|. This is where
the remaining argument parsing takes place, and the \cs{tabularnewline} is
inserted, after which control is passed to \verb|\@@_bol:| in order to begin a
new line---unless we're at the end of the environment.

\begin{source}
\cs_new:Npn \@@_eol_handle_args:nnn #1 #2 #3 {
    % Make extra-space default key for keyless value:
    \bool_set_true:N \l_@@_in_eol_bool
    \@@_keys_set_overlay:nnn { #2 } { pseudo } { hl }
    \keys_set:nn { pseudo } { #3 }
\end{source}
The variables underlying the keys (\verb|\l_@@_label_tl|, etc.) are kept
local, so they'll be restored after the environment, but in order to carry
over to the next line and its preamble, we need to perform some global
assignments here.
\begin{source}
    \tl_gset_eq:NN \pseudolabel   \l_@@_label_tl
    \tl_gset_eq:NN \pseudobol     \l_@@_bol_tl
    \tl_gset_eq:NN \pseudoeol     \l_@@_eol_tl
    \tl_gset_eq:NN \pseudosetup   \l_@@_setup_tl
\end{source}
If starred, clear out the prefix:
\begin{source}
    \IfBooleanTF { #1 } {
        \tl_gclear:N \g_@@_cur_prefix_tl
    } {
        \tl_gset_eq:NN \g_@@_cur_prefix_tl \pseudoprefix
    }
}
\NewDocumentCommand \@@_eol_tail { s d<> +O{ } } {
    \@@_eol_handle_args:nnn{#1}{#2}{#3}
\end{source}
A new line is begun only if we're not at the end of the (or, at least of
\emph{some}) environment. (We could have put the \cs{tabularnewline} outside,
but then we'd have a conditional at the beginning of the next line, which
would mess up \cs{bottomrule} or the like. We need to keep \verb|\@@_bol:|
alone at the start of the line.) We call \cs{tabularnewline} either way, in
particular for it to use any extra space provided to \refk{extra-space}.

It seems providing a zero-length extra space in \cs{tabularnewline} can cause
trouble,\footnote{Cf.\ \url{https://github.com/mlhetland/pseudo.sty/issues/21}}
so we treat that as a special case.
\begin{source}
    \dim_compare:nNnTF \l_@@_extra_space_tl = { 0pt } {
        \tl_set_eq:NN \l_tmpa_tl \tabularnewline
    } {
        \tl_set:Nx \l_tmpa_tl {
            \exp_not:N \tabularnewline [ \l_@@_extra_space_tl ]
        }
    }
    \@@_skip_pars:n {
        \peek_meaning_ignore_spaces:NTF \end {
            \l_tmpa_tl
        } {
            \pseudoeol
            \l_tmpa_tl
            \@@_bol:
        }
    }
}
\end{source}
And here is the actual \verb|\@@_eol:| command:
\begin{source}
\cs_new:Npn \@@_eol: {

    \@@_per_char:nnn { + } {
        \@@_inc_indent:
    } {
    \@@_per_char:nnn { - } {
        \@@_dec_indent:
    } {
        \@@_eol_tail
    } }

}
\end{source}
%
The \verb|\@@_bol:| command (currently) just inserts the \refk{prefix}:
\begin{source}
\cs_new:Npn \@@_bol: {
    \g_@@_cur_prefix_tl
}
\end{source}
%
\section{Various user commands}

A few user-level wrappers around internal commands. First, a couple primarily
for use in the \refk{preamble}, together with \refc{pseudosavelabel} and
\refc{pseudofont}:
\begin{source}
\NewDocumentCommand \pseudohpad { } {
    \skip_horizontal:n { \l_@@_hpad_tl - \tabcolsep }
}
\NewDocumentCommand \pseudoindent { } {
    \@@_indent:N { \g_@@_indent_level_int }
}
\end{source}
The \refc{RestorePseudoBackslash} command simply redefines the row separator,
and is used at the start of the \refe{pseudo} environment. It may be useful for
the user if some other construct redefines \refc{\bslash} as well. (This is
similar to the \cs{arraycr} command of the \pkg{array} package.)
\begin{source}
\NewDocumentCommand \RestorePseudoBackslash { } {
    \cs_gset_eq:NN \\ \@@_eol:
}
\end{source}
We also have a command for restoring our definition of \cs{=} if it has been
overwritten:
\begin{source}
\NewDocumentCommand \RestorePseudoEq { } {
    \cs_gset_eq:NN \= \@@_eq:
}
\end{source}
Finally, two utilities for working with options. The first (\refc{pseudoset})
directly sets a collection of keys, while the second
(\refc{pseudodefinestyle}) defines a new key which can be used as a shortcut
for setting multiple keys at some later point:
\begin{source}
\NewDocumentCommand \pseudoset { +m }
    { \@@_set:n { #1 } }

\NewDocumentCommand \pseudodefinestyle { m +m } {
    \keys_define:nn { pseudo } {
        #1 .meta:n = {
            #2
        }
    }
}
\end{source}
%
% Not allowed to use \code in header, here:
\section{The \codefont{pseudo} environment}

While this is the main attraction, it's essentially just an augmented
\code{tabular} environment, which does a bit of setup initially, using the
various macros already described.

\begin{source}
\NewDocumentEnvironment { pseudo } { +o s d<> +O{ } } {

    \group_begin:

    \@@_cs_gsave_as:NN \\ \c_@@_saved_cr_cs
    \@@_cs_gsave_as:NN \= \c_@@_saved_eq_cs

    % \RestorePseudoBackslash is inside the tabular
    \RestorePseudoEq

    \int_set:Nn \g_@@_last_saved_line_int {\arabic{pseudoline}}
    \@@_star_setup:

    \IfNoValueF { #1 } {
        \pseudoset { #1 }
    }
    \@@_set_indent_length:

    % If not manually set as compact/noncompact,
    % set automatically:
    \bool_if:NF \l_@@_compact_def_bool {
        \bool_set:Nn \l_@@_compact_bool {
            \mode_if_horizontal_p: && \mode_if_inner_p:
        }
    }

    \bool_if:nF { \l_@@_compact_bool } {

        \skip_set:Nn \l_tmpa_skip {
            \l_@@_topsep_tl
        }
        \mode_if_vertical:TF {
            \skip_add:Nn \l_tmpa_skip { \l_@@_partopsep_tl }
        } {
            \unskip \par
        }

        \addvspace { \l_tmpa_skip }

        \noindent
        \skip_horizontal:n{ \dim_eval:n { \l_@@_left_margin_tl } }

    }

    \dim_set:Nn   \tabcolsep    { \l_@@_hsep_tl / 2 }
    \tl_set_eq:NN \arraystretch \l_@@_line_height_tl

    \stepcounter{pseudoenv}
    \setcounter{pseudoline}{\l_@@_start_tl}
    \addtocounter{pseudoline}{-1}
\end{source}
Before starting the actual tabular environment, we insert any user-configured
initialization.
\begin{source}
    \tl_use:N \l_@@_init_tl
    \tl_use:N \l_@@_begin_tabular_tl
\end{source}
We use \cs{noalign} to be able to place these definitions inside the tabular,
without messing up \cs{multicolumn} or \cs{hline} or the like. It's not really
supposed to be used in \pkg{expl3}; the alternative would be to create an extra
dummy line, like:
\begin{texexp}[listing]
\skip_vertical:n{ -\dim_eval:n{ \box_ht:N \@arstrutbox +
                                \box_dp:N \@arstrutbox } }
\tabularnewline
\end{texexp}
This would give us a fresh start, without moving vertically. It's probably
more hacky than just using \cs{noalign} here, though, so\,\dots
\begin{source}
    \tex_noalign:D {
\end{source}
We keep the \refc{\bslash}-definition inside the \code{tabular}, to override the
redefinition placed there by \pkg{array}, without patching any internals:
\begin{source}
        \RestorePseudoBackslash
\end{source}
In a \code{tabularx}, for example, the body is executed multiple times, so we
must make sure that any resets that are performed---such as setting the
initial indentation level---are performed each time:
\begin{source}
        \int_gset_eq:NN \g_@@_indent_level_int
                        \l_@@_initial_indent_level_int
\end{source}
Finally, we handle the line arguments, just like with the row separator:
\begin{source}
        \@@_eol_handle_args:nnn{#2}{#3}{#4}
    }
\end{source}
Definitions and setup are done, we've left the \cs{noalign}, and we can start
the line:
\begin{source}

    \@@_bol:

} {

    \tl_use:N \l_@@_end_tabular_tl
\end{source}
We'll only adjust spacing here if we're not \refk{compact}. Otherwise, we'll
just end the current group:
\begin{source}
    \bool_if:nTF { \l_@@_compact_bool } {

        \group_end:

    } {

        \mode_if_vertical:F {
            \unskip \par
            \group_insert_after:N \@endparenv
        }

        \addvspace{ \l_tmpa_skip }
\end{source}
To ensure any local changes to \refk{prevdepth} are used, we expand its local
value before setting cs{prevdepth} \emph{outside} the group.\footnote{See,
e.g., \url{https://tex.stackexchange.com/questions/56294}.}
\begin{source}
        \exp_args:NNNV
            \group_end:
            \dim_set:Nn \prevdepth \l_@@_prevdepth_tl

    }

}
\end{source}
The starred version of the environment is just a wrapper that uses the custom
(and overridable) \code{starred} style:
\label{p:starred}%
\begin{source}
\pseudodefinestyle{ starred }{
    preamble = {
        >{\pseudohpad\pseudoindent\pseudofont}
        l
        <{\pseudohpad}
    },
    prefix = {\pseudobol},
}

\NewDocumentEnvironment { pseudo* } { +O{} } {
    \begin{pseudo}[starred, #1]
    % \begin{pseudo} will "eat" any remaining arguments to pseudo*
} {
    \end{pseudo}
}
\end{source}

\section{Boxes and floats}
\label{sec:floatsrc}

Some spacing and width values are taken from \pkg{booktabs}, to partly emulate
its table appearance. If \pkg{booktabs} is not loaded, we'll just define these
constants ourselves; if \pkg{booktabs} is loaded later, it will blithely
overwrite these.
\begin{source}
\@ifpackageloaded { booktabs } { } {
    \dim_const:Nn \aboverulesep       { .40ex }
    \dim_const:Nn \belowrulesep       { .65ex }
    \dim_const:Nn \heavyrulewidth     { .08em }
    \dim_const:Nn \lightrulewidth     { .05em }
}
\end{source}
We also define some line widths based on those used by
\pkg[https://ctan.org/pkg/pgf]{tikz}.
% ultra thin   0.1pt
% very thin    0.2pt
% thin         0.4pt
% semithick    0.6pt
% thick        0.8pt
% very thick   1.2pt
% ultra thick  1.6pt
\begin{source}
\dim_const:Nn \c_@@_very_thin_dim     { 0.2pt }
\dim_const:Nn \c_@@_thin_dim          { 0.4pt }
\dim_const:Nn \c_@@_semithick_dim     { 0.6pt }
\end{source}
We'll be adjusting the spacing after the contents based on the value of
\cs{prevdepth}. If \cs{prevdepth} is negative, this is suppressed. Otherwise, we
add vertical space to the \cs{prevdepth}, to take us to (at least)
\code{.3\cs{baselineskip}}. Since the mechanism is the same for the title and
the body, we define a macro:
\begin{source}
\cs_new:Npn \@@_prevdepth_adjustment: {
    \par % Ensure vertical mode
    \dim_compare:nNnF \prevdepth < \c_zero_dim {
        \dim_compare:nNnT \prevdepth < { .3 \baselineskip } {
            \skip_vertical:n { .3 \baselineskip - \prevdepth }
            \skip_vertical:N \c_zero_dim % Hide previous skip
        }
    }
}
\end{source}
To permit the styling specifically of \refe{pseudo} environments inside our
boxes, we define and use a \pkg{pseudo} style, and a hook (token list) that may
overridden by the user:
\begin{source}
\pseudodefinestyle { in-float } {
    % Initially empty
}
\tl_new:N \l_@@_float_init_tl
\end{source}
We now define some \pkg{tcolorbox} box styles. Rather than importing
\pkg{tcolorbox}, we just use its key management mechanism, \pkg{pgfkeys}, with
the appropriate name\-space.
\begin{source}
\pgfqkeys { /tcb/pseudo } {
\end{source}
We begin by defining our hook \refk{pseudo/init}.
\begin{source}
    init/.code = {
        \tl_set:Nn \l_@@_float_init_tl { #1 }
    },
\end{source}
The first box style (\refk{pseudo/boxruled}) is the basis for the others.
\begin{source}
boxruled/.style = {
\end{source}
By default, our boxes aren't floats, but if the \code{float} style is used,
we'll want to have the placement configured. The \pkg{tcolorbox} default is
\code{htb}, but we're emulating normal floats, so we'll use the normal \LaTeX{}
default:
\begin{source}
    floatplacement = tbp,
\end{source}
Before the contents (which uses the upper part of the box), we adjust some
distances, and set \cs{prevdepth}, for consistent vertical spacing of the first
line. These settings may be overridden using \code*{before upper app}, which
appends code to \code*{before upper}. For example, one could change the
\cs{topsep} by using \code*{before upper app =
\braces{\cs{topsep}10pt}}.\footnote{While you might want to modify \cs{parskip},
\cs{topsep} or \cs{partopsep}, there's probably no need to change
\cs{prevdepth}.}%
\label{p:before-upper}
\begin{source}
    before~upper = {
        \dim_set:Nn \parskip    { .3 \baselineskip }
        \dim_set:Nn \topsep     { .2 \baselineskip }
        \dim_set:Nn \partopsep  { 0pt              }
        \dim_set:Nn \prevdepth  { .3 \baselineskip }
        \RestorePseudoEq            % Broken in floats
        \pseudoset { in-float }     % User hook (style)
        \l_@@_float_init_tl         % User hook (code)
    },
\end{source}
At the end of the contents, we add some spacing, again for consistent vertical
alignment.
\begin{source}
    after~upper = \@@_prevdepth_adjustment:,
\end{source}
Now we add spacing before and after the box, when it's not used with
the \code{float} key. We just mirror the spacing of the \refe{pseudo}
environment (except without the support for \refk{partopsep}).
\begin{source}
    beforeafter~skip~balanced = \l_@@_topsep_tl,
\end{source}
Now we set up basic spacing for the contents. The spacing above and below the
title is the same as for the top row of a \pkg{booktabs} tabular. For the
``body'' of the box (and the left/right), we add some extra space.
\begin{source}
    boxsep              = 0pt,
    toptitle            =   \belowrulesep,
    bottomtitle         =   \aboverulesep,
    top                 = 2 \belowrulesep,
    bottom              = 2 \aboverulesep,
    left                = 2 \belowrulesep,
    right               = 2 \belowrulesep,
\end{source}
The title has a separate part called the \emph{description} (in \pkg{tcolorbox}
theorem terms). We give the title one font (bold), and then reset that to
\cs{normalfont} when we get to the description.
\begin{source}
    fonttitle           = \bfseries,
    description~font    = \normalfont,
\end{source}
The spacing above and below the title is adjusted as for the body. We want to
separate the initial part of the title (e.g., ``Algorithm 3.2'') from the
description by an \cs{enskip} (\code{.5em} horizontal space). However, a single
normal space is hard-coded into \pkg{tcolorbox}, so we'll subtract the width of
that. (We make sure to do this with \cs{normalfont}, to not get the units warped
by an extended bold, for example.)
% Cf. https://tex.stackexchange.com/questions/229640/
\begin{source}
    before~title        =
        \dim_set:Nn \prevdepth  { .3 \baselineskip },
    after~title         = \@@_prevdepth_adjustment:,
    separator~sign      = {
        \normalfont
        \skip_horizontal:n { .5em - \fontdimen2\font\space }
    },
\end{source}
Finally, some basic styling.
\begin{source}
    sharp~corners,
    colback             = white,
    colbacktitle        = white,
    coltitle            = black,
    colframe            = black,
    boxrule             = \c_@@_thin_dim,
    titlerule           = \c_@@_very_thin_dim,
},
\end{source}
The remaining box styles are based on \code{boxruled}, but rely on other skins
(\code{empty} and \code{tile}), which remove the default frame drawing, as some
of the frame are removed. (It would be possible to simply set the relevant
widths to zero, but this tends to leave perceptible hairlines in most PDF
viewers---probably because the fram is drawn by \emph{filling} rather than
\emph{drawing}.)
\begin{source}
ruled/.style = {
    pseudo/boxruled,
    empty,
\end{source}
Even though we've removed the default frame, we do want some rules. First the
various rule thicknesses (and some horizontal spacing) are set. The ones
that are missing have their thicknesses set to zero, for spacing/positioning
purposes. The titlerule is drawn normally, but for the top and bottom rules, we
need to use the \code{borderline} mechanism.
\begin{source}
    boxrule             = 0pt,
    toprule             = \heavyrulewidth,
    titlerule           = \lightrulewidth,
    bottomrule          = \heavyrulewidth,
    left                = 0pt,
    right               = 0pt,
    titlerule~style     = draw,
    borderline~north    = {\heavyrulewidth}{0pt}{black},
    borderline~south    = {\lightrulewidth}{0pt}{black},
},
\end{source}
The \code{booktabs} is a variation of \code{ruled}, where the bottom rule is
also thick, to match the style of \code{booktabs} tables.
\begin{source}
booktabs/.style = {
    pseudo/ruled,
    no~borderline,
    bottomrule          = \heavyrulewidth,
    borderline~horizontal = {\heavyrulewidth}{0pt}{black}
},
\end{source}
The \code{boxed} style is similar, with the titlerule removed, and with the
borderline drawn on all sides. Finally, we want to ``simulate'' the title just
being the first paragraph of the contents, so we set the space above the title
\emph{almost} equal to the space used elsewhere above the content, zero out the
spacing after the title, and make the top spacing equal to the the normal
\cs{parskip} (which we set to \code{.3\cs{baselineskip}} in \code{before
upper}).
\begin{source}
boxed/.style = {
    pseudo/boxruled,
    empty,
    titlerule           = 0pt,
    borderline          = {\c_@@_thin_dim}{0pt}{black},
    toptitle            = 1.5 \belowrulesep,
    bottomtitle         = 0pt,
    top                 = 0.3 \baselineskip,
},
\end{source}
The \code{tworuled} style is based on \code{boxed} (including the spacing
adjustment between title and body), but removes the previously drawn
borderlines, adjusts the thicknesses, and draws new horizontal lines.
\begin{source}
tworuled/.style = {
    pseudo/boxed,
    no~borderline,
    left                = 0pt,
    right               = 0pt,
    boxrule             = 0pt,
    toprule             = \heavyrulewidth,
    bottomrule          = \heavyrulewidth,
    borderline~horizontal = {\heavyrulewidth}{0pt}{black},
},
\end{source}
Finally, the \code{filled} style uses the \code{tile} skin, which has no
frame, and is designed for filling. In addition to the colors, there's a slight
spacing adjustment.\footnote{The \code{tile} skin also sets things like
\code*{sharp corners} and \code{fonttitle}, so some of what we inherit from
\code{boxruled} is a bit redundant, here.} Since we have no border, we increase
the spacing a bit (though not at the top, to prevent a ``top-heavy'' look,
especially when dropping the title).
\begin{source}
filled/.style = {
    pseudo/boxruled,
    tile,
    colback             = \pseudohlcolor,   % black!12
    colbacktitle        = lightgray,        % black!25
    bottom              = 2 \aboverulesep + \c_@@_thin_dim,
    left                = 2 \belowrulesep + \c_@@_thin_dim,
    right               = 2 \belowrulesep + \c_@@_thin_dim,
}
\end{source}
And that ends the \pkg{tcolorbox} definitions:
\begin{source}
} % \pgfqkeys
\end{source}


\section{Deprecations and warnings}

Some commands are no longer intended for use, but are included for backward
compatibility. These will issue a deprecation warning when used.

% Not sure why there should be no `~` after the parameters?
\begin{source}
\msg_new:nnn { pseudo } { useinstead } {
    The~#1 command~(used~\msg_line_context:)~is~deprecated;~
    use~#2 instead.
}

\cs_new:Npn \@@_use_instead:nn #1 #2 {
    \msg_warning:nnnn { pseudo } { useinstead } { #1 } { #2 }
    % \tl_gset_eq:NN #1 #2
}

\NewDocumentCommand \pseudoslash { } {
    \@@_use_instead:nn \pseudoslash \RestorePseudoBackslash
    \RestorePseudoBackslash
}

\NewDocumentCommand \pseudoeq { } {
    \@@_use_instead:nn \pseudoeq \RestorePseudoEq
    \RestorePseudoEq
}
\end{source}
Finally, we define a warning to issue if \refk{hl} is used without \refk{hpad}.
\begin{source}
\msg_new:nnn { pseudo } { hl-without-hpad } {
    hl~used~without~hpad~\msg_line_context:.
}
\end{source}


\section{Compatibility}
\label{sec:compat}

If the box and float functionality is used with a version of \pkg{tcolorbox}
prior to~4.40 (e.g., on \url{https://arxiv.org}, at the time of writing), the
\code*{beforeafter skip balanced} option won't be defined
\begin{source}
\pgfkeysifdefined { /tcb/beforeafter~skip~balanced/.@cmd } { } {
\end{source}
To handle this, at least for the time being, \pkg{pseudo} implements a fallback
version of this option.
\begin{source}
\pgfqkeys { /tcb } {
    before~skip~balanced/.style = { before = {
        \int_compare:nNnF { \lastnodetype } = { -1 } {
            \par
            \mode_if_vertical:T {
                \@@_if_minipage:
                    \dim_compare:nNnTF \parskip > \c_zero_dim {
                        \addvspace{ -\parskip }
                    }
                \else:
                    \bool_lazy_or:nnTF {
                        \dim_compare_p:nNn
                            \prevdepth < \c_zero_dim
                    } {
                        \dim_compare_p:nNn
                            \prevdepth > { .3 \baselineskip }
                    } {
                        \addvspace { \skip_eval:n {
                            #1 - \parskip
                        } }
                    } {
                        \addvspace { \skip_eval:n {
                            #1 + .3 \baselineskip
                            - \prevdepth - \parskip
                        } }
                    }
                \fi:
                \nointerlineskip
            }
        }
        \dim_set_eq:NN \lineskip \c_zero_dim
        \noindent
    } },
    after~skip~balanced/.style = { after = {
        \par
        \mode_if_vertical:T {
            \dim_set:Nn \prevdepth { .3\baselineskip }
            \addvspace { \skip_eval:n { #1 - \parskip } }
        }
    } },
    beforeafter~skip~balanced/.style = {
        before~skip~balanced = { #1 },
        after~skip~balanced  = { #1 }
    }
}
\end{source}
We need to know if the box is in a \code{minipage}, and this is normally
detected as part of \cs{tcb@apply@box@options}. We override that macro (if
\pkg{tcolorbox} has been loaded by the time we reach the end of the preamble) to
insert the approproate definition.
\begin{source}
\RequirePackage{etoolbox}

\AtEndPreamble {
    \@ifpackageloaded { tcolorbox } {
        \tl_set_eq:NN \@@_orig_tcbopt \tcb@apply@box@options
        \def \tcb@apply@box@options #1 {
            \@@_orig_tcbopt { #1 }
            \tl_set_eq:NN \@@_if_minipage: \if@minipage
        }
    } { }
}
\end{source}
End of \cs{pgfkeysifdefined}:
\begin{source}
}
\end{source}
In older version of \pkg{tcolorbox}, we end up with extra space at the top of
the box contents. The simple solution here it so simply add \code{-\cs{parskip}}
of vertical space. This doesn't really do much harm, but it is redundant with
newer versions, and it does interfere with the use of \code*{before upper app},
for example. Therefore, we only add this spacing in older versions (for
simplicity, just going with 4.x and older). We do this at the end of the
preamble, and only if \pkg{tcolorbox} has actually been loaded at that point.
\begin{source}
\AtEndPreamble {
    \@ifpackageloaded { tcolorbox } {

        \cs_new:Npn \@@_vmaj:n #1 { \@@_vmaj_aux:w #1 \q_stop }
        \cs_new:Npn \@@_vmaj_aux:w #1 . #2 \q_stop { #1 }

        \tl_set:Nx \l_tmpa_tl {
            \exp_args:No \@@_vmaj:n \tcb@version
        }

        \int_compare:nNnT \l_tmpa_tl < 5 {

            \tcbuselibrary { hooks }
            \tcbset {
                pseudo/boxruled/.append~style = {
                    before~upper~app = \vspace { -\parskip }
                }
            }

        }

    }

}
\end{source}

\printbibliography

\end{document}

